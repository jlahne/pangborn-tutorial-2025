[["index.html", "Publication-quality data visualizations using the R tidyverse Introduction and welcome Introductions Today’s agenda How we’re going to run PSA: not-knowing is normal!", " Publication-quality data visualizations using the R tidyverse Jacob Lahne1 Kyle Hamilton2 Introduction and welcome Welcome to the Sensometrics Workshop “Publication-quality data visualizations using the R tidyverse”! This workshop is going to be conducted not using slides, but through livecoding. That means we are going to run code lines in the console or highlight and run code in scripts and other files. It is also an opportunity and encouragement for you to follow along. Along with introducing ourselves for today’s workshop, we’re going to discuss a bit about how that will work here. Introductions Kyle Hamilton, PhD Kyle Hamilton is the Lead Sensory Data Analyst and Trainer at Flavor Linguist, LLC, in the US. Kyle’s primary research interest is flavor language, including the ways that people talk about flavors using their own words in different contexts. Flavor Linguist offers data analysis services for language and survey data, or training and support for those looking to do it themselves. Jacob Lahne, PhD Jacob Lahne is an Associate Professor of Food Science &amp; Technology at Virginia Tech, in the United States. He runs the Virginia Tech Sensory Evaluation Laboratory, as well as teaching courses in data analytics and coding for food-science research. His main research focuses are sensory data-analysis methodologies and investigating the sensory properties of fermented and distilled foods and beverages. Elizabeth Clark, PhD Elizabeth Clark is a Senior Scientist in Sensory &amp; Consumer Sciences at McCormick &amp; Company Inc. — a global leader in flavor operating in two segments across 170 countries and territories. McCormick’s passion for Sensory &amp; Consumer Science has led to published research on a replacement for the Scoville heat method for the sensory determination of pungency in capsicum products (Gillette, Appel, &amp; Leggo, 1984), The Sensory Quality System (SQS): a global quality control solution (King et.al, 2022), the EsSense Profile®— a scientific measurement of the human emotional response to flavor (King &amp; Meiselman, 2010), and The Wellsense Profile™ — a questionnaire to measure consumer wellness with foods (King et.al, 2015). Leveraging her interest in data analytics &amp; coding, Elizabeth is helping McCormick usher in a new era of sensory research geared toward addressing rapidly evolving challenges faced by global food &amp; beverage companies. Today’s agenda Today’s workshop is going to take ~3 hours, and we’ll be covering the following material: Importing/Exporting/Organizing Data Reading tabular data Basic data cleaning Saving/exporting data Intro to ggplot2 Fine-Tuning Publication-Quality ggplots Adding layers and geoms (e.g., ggrepel) Plot-builders (e.g., factoextra) Combining plots Exporting plots Formatting text Ordering categorical variables How we’re going to run This workshop is going to be run with livecoding, as noted above. This means we won’t be using slides or a prepared video, but running through code step by step to show how these tools are used in practice. We encourage you to also follow along with livecoding, because the best way to learn coding is to actually do it. Recommended approach for livecoding We recommend that you download the pre-made archive of code and data from the workshop github repo. This archive, when unzipped, will have a folder structure and a .Rproj file. We recommend that you close out RStudio, unzip the archive, and double click the .Rproj file in that folder, which will open a new session of RStudio with proper settings (like the home directory) for the files for this workshop. In that folder, you will find a data/ folder with the necessary data for the workshop, and a script named sensometrics-all-code.R. This latter file contains all of the code demonstrated in this workshop for your future reference. You can also follow along with the code at the workshop’s page hosted on github.io (which you’re reading right now), and which will remain available after this workshop. Once you’re in RStudio, go to the File &gt; New File &gt; R Script menu to open a new script. Scripts are basically workbooks for you to store sequential lines of code to be run in the Console. It is where you can livecode along! Even though we are giving you all of the code you need right now, you will learn a lot more if you actively write out the code to follow along, rather than just running the entire code file. The Console is the place to run code that is short and easy to type, or that you’re experimenting with. It will allow you to write a single line of code, and after you hit return, R will execute the command. This is great for “interactive programming”, but it isn’t so great for building up a complex workflow, or for following along with this workshop! You can write multiple lines of code in your R Script, then execute each one in any order (although keeping a logical sequence from top to bottom will help you keep track of what you’re doing). In an R script, everything is expected to be valid R code. You can&#39;t write this in an R script because it is plain text. This will cause an error. # If you want to write text or notes to yourself, use the &quot;#&quot; symbol at the start of # every line to &quot;comment&quot; out that line. You can also put &quot;#&quot; in the middle of # a line in order to add a comment - everything after will be ignored. 1 + 1 # this is valid R syntax print(&quot;hello world&quot;) # this is also valid R syntax To run code from your R script, put your cursor on the line you want to run and either hit the run button with the green arrow at the top left or (my preferred method) type cmd + return (on Mac) or ctrl + return (on PC). Dealing with errors Coding means making mistakes. This is fine–as you will surely see today, we will make a ton of trivial errors and have to fix things on the fly. If you run into trouble, try looking carefully at what you’ve done and see if you can see what went wrong. You can also make use of the help files in R. You can always get help on a particular function by typing ?&lt;search term&gt;, which will make the help documentation for whatever you’ve searched for appear. For example, try typing the following to get help for the sessionInfo() command: ?sessionInfo But what if you don’t know what to search for? By typing ??&lt;search term&gt; you will search all help files for the search term. R will return a list of matching articles to you in the help pane. This is considerably slower, since it’s searching hundreds or thousands of text files. Try typing ??install into your console to see how this works. You will notice that there are two types of results in the help list for install. The help pages should be familiar. But what are “vignettes”? Try clicking on one to find out. Vignettes are formatted, conversational walkthroughs that are increasingly common (and helpful!) in R packages. Rather than explaining a single function they usually explain some aspect of a package, and how to use it. And, even better for our purposes, they are written in R Markdown. Click the “source” link next to the vignette name in order to see how the author wrote it in R Markdown. This is a great way to learn new tricks. While you can find vignettes as we just did, a better way is to use the function browseVignettes(). This opens a web browser window that lists all vignettes installed on your computer. You can then use cmd/ctrl + F to search using terms in the web browser and quickly find package names, function names, or topics you are looking for. PSA: not-knowing is normal! Above, I mentioned “help files”. How do we get help when we (inevitably) run into problems in R? There are a couple steps you will find helpful in the future: Look up the help file for whatever you’re doing. Do this by using the syntax ?&lt;search item&gt; (for example ?c gets help on the vector command) as a shortcut on the console. Search the help files for a term you think is related. Can’t remember the command for making a sequence of integers? Go to the “Help” pane in RStudio and search in the search box for “sequence”. See if some of the top results get you what you need. The internet. Seriously. I am not kidding even a little bit. R has one of the most active and (surprisingly) helpful user communities I’ve ever encountered. Try going to google and searching for “How do I make a sequence of numbers in R?” You will find quite a bit of useful help. I find the following sites particularly helpful Stack Overflow Cross Validated/Stack Exchange Seriously, Google will get you most of the way to helpful answers for many basic R questions. We may come back to this, but I want to emphasize that looking up help is normal. I do it all the time. Learning to ask questions in helpful ways, how to quickly parse the information you find, and how to slightly alter the answers to suit your particular situation are key skills. Getting Help If you get stuck and can’t figure out what went wrong, we are here to help! Because we have 2 instructors for this workshop, one of us is available to help at any time. When you run into trouble, please raise your hand. We’ll be keeping an eye out, and whichever instructor isn’t livecoding will come to help you. If your issue is a common one or something we think is worth noting, don’t worry–we’ll make time to discuss it! Virginia Tech, jlahne@vt.edu↩︎ Flavor Linguist, hamilton@flavorlinguist.com↩︎ "],["importing-and-wrangling-data.html", "1 Importing and wrangling data 1.1 Motivation: exploring berry and cider CATA/liking data 1.2 Getting data into R 1.3 The destination 1.4 Saving your data 1.5 Wrap up", " 1 Importing and wrangling data Now that everyone is on the same page for how we’re going to use R, we’re going to dive right into importing our data into R, exploring it, and–most importantly–visualizing it. In this part of the tutorial, we are going to focus on getting data into R and manipulating it. Personally, I prefer to see the reason for doing something, rather than being shown a bunch of building blocks and not seeing how they fit together. Therefore, we’re going to start off this section with a complete work flow for importing and visualizing some real results, and then work backward as we unpack how and why we’ve taken particular steps. 1.1 Motivation: exploring berry and cider CATA/liking data Before we begin, we need to make sure we’ve loaded the packages we’re going to use. # This package is actually a set of utility packages we will use a lot library(tidyverse) 1.2 Getting data into R Before we’re able to analyze anything, we need to get data into R. In the workshop archive you downloaded, the data/ directory has files called clt-berry-data.csv and CiderDryness_SensoryDATA.csv. These are the files that hold the raw data. 1.2.1 Where the data live To get these data into R, we need to briefly talk about working directories because this is how R “sees” your computer. It will look first in the working directory, and then you will have to tell it where the file is relative to that directory. If you have been following along and opened up the .Rproj file in the downloaded archive, your working directory should be the archive’s top level, which will mean that we only need to point R towards the data/ folder and then the clt-berry-data.csv file. We can check the working directory with the getwd() function. getwd() ## [1] &quot;/Users/jake/Library/CloudStorage/Dropbox/Work/Collaborations/2025/pangborn-tutorial-2025&quot; Therefore, relative to the working directory, the file path to this data is data/clt-berry-data.csv. Please note that this is the UNIX convention for file paths: in Windows, the backslash \\ is used to separate directories. Happily, RStudio will translate between the two conventions, so you can just follow along with the macOS/UNIX convention (/) in this workshop. raw_berry_data &lt;- read_csv(file = &quot;data/clt-berry-data.csv&quot;) raw_cider_data &lt;- read_csv(file = &quot;data/CiderDryness_SensoryDATA.csv&quot;) As a note, in many countries the separator (delimiter) will be the semi-colon (;), since the comma is used as the decimal marker. To read files formatted this way, you can use the read_csv2() function. If you encounter tab-separated values files (.tsv) you can use the read_tsv() function. If you have more non-standard delimiters, you can use the read_delim() function, which will allow you to specify your own delimiter characters. Excel stores data by default in the .xlsx format, which can be read by installing and using the readxl package (or saving Excel data as .csv). You can also read many other formats of tabular data using the rio package (“read input/output”), which can be installed from CRAN (using, as you have learned, install.packages(\"rio\")). The read_csv() function creates a type of object in R called a tibble, which is a special type of data.frame. These are rectangular “spreadsheet-like” objects like you would encounter in Excel or manipulate in JMP or SPSS. 1.3 The destination The plan here is to present “full” workflows for data import, wrangling, and visualization below so as to give a skeleton to work through. This is going to look like a lot of code at once, but I don’t use anything in these workflows that we will not be covering (in some way!) today. Hopefully, by the end of today’s workshop you will be able both to understand and dissect complex code and use it to build your own analyses and visualizations. 1.3.1 Cider These data come from a small consumer study on 3 commercial “hard” (alcoholic) ciders, served in two conditions (chilled or unchilled) to 48 consumers, who used a pre-defined CATA lexicon, rated overall liking, and evaluated cider “dryness” on a 4-pt, structured line scale. The full details of the study are published in Calvert et al. (2022). Here, we develop a complex and informative Correspondence Analysis (CA) plot of these results, as this is a very common output for sensory scientists. raw_cider_data &lt;- read_csv(&quot;data/CiderDryness_SensoryDATA.csv&quot;) cider_samples &lt;- raw_cider_data %&gt;% select(Sample_Name, Temperature) %&gt;% unite(Sample_Name, Temperature, col = &quot;sample&quot;, sep = &quot; &quot;, remove = FALSE) %&gt;% distinct() cider_contingency &lt;- raw_cider_data %&gt;% select(Sample_Name, Temperature, Fresh_Apples:Synthetic) %&gt;% unite(Sample_Name, Temperature, col = &quot;sample&quot;, sep = &quot; &quot;) %&gt;% group_by(sample) %&gt;% summarize(across(where(is.numeric), ~sum(.))) %&gt;% column_to_rownames(&quot;sample&quot;) ca_cider &lt;- cider_contingency %&gt;% FactoMineR::CA(graph = FALSE) ca_cider_coords &lt;- ca_cider$row$coord %&gt;% as_tibble(rownames = &quot;name&quot;) %&gt;% mutate(type = &quot;row&quot;) %&gt;% bind_rows( ca_cider$col$coord %&gt;% as_tibble(rownames = &quot;name&quot;) %&gt;% mutate(type = &quot;col&quot;) ) %&gt;% left_join(cider_samples, join_by(name == sample)) %&gt;% mutate(name = if_else(is.na(Sample_Name), name, Sample_Name), name = str_replace_all(name, &quot;_&quot;, &quot; &quot;), name = str_replace(name, &quot;FullBodied&quot;, &quot;Full Bodied&quot;), modality = if_else(type == &quot;col&quot;, case_when(name == &quot;Sweet&quot; ~ &quot;Taste&quot;, name == &quot;Bitter&quot; ~ &quot;Taste&quot;, name == &quot;Sour&quot; ~ &quot;Taste&quot;, name == &quot;Smooth&quot; ~ &quot;Mouthfeel&quot;, name == &quot;Dry&quot; ~ &quot;Mouthfeel&quot;, name == &quot;FullBodied&quot; ~ &quot;Mouthfeel&quot;, .default = &quot;Aroma&quot;), NA)) nice_cider_labels &lt;- labs(x = str_c(&quot;Dimension 1, &quot;, round(ca_cider$eig[1, 2], 1), &quot;% of inertia&quot;), y = str_c(&quot;Dimension 2, &quot;, round(ca_cider$eig[2, 2], 1), &quot;% of inertia&quot;), subtitle = &quot;Correspondence Analysis biplot (symmetric)&quot;, title = &quot;Effect of cider serving temperature on consumer sensory perception&quot;) p2_ca_cider_cata &lt;- ca_cider_coords %&gt;% mutate(font = if_else(type == &quot;row&quot;, &quot;plain&quot;, &quot;italic&quot;)) %&gt;% ggplot(aes(x = `Dim 1`, y = `Dim 2`)) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, color = &quot;darkgrey&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;darkgrey&quot;) + geom_point(aes(color = type, shape = Temperature), data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;), size = 3) + ggrepel::geom_text_repel(aes(label = name, color = type, fontface = font), show.legend = FALSE) + coord_equal() + theme_linedraw() + theme(legend.position = &quot;bottom&quot;) + nice_cider_labels + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) + scale_shape_manual(values = c(8, 16)) + guides(shape = guide_legend(), color = &quot;none&quot;) p2_ca_cider_cata 1.3.2 Berries Here we are going to import and process data from a study on berries. These data come from a large, central-location study on berries, the methodological details of which are published in Yeung et al. (2021). Very briefly, the data describe the attributes and liking scores reported by consumers for a variety of berries across multiple CLTs. A total of 969 participants (Subject Code) and 23 berries (Sample Name) were involved in these tests, with only one species of berry (blackberry, blueberry, raspberry, or strawberry) presented during each CLT. In the actual experimental design, subjects got multiple sample sets (so there are not 969 unique subjects), but here we will treat them as unique for ease of description. # Import the data raw_berry_data &lt;- read_csv(file = &quot;data/clt-berry-data.csv&quot;) %&gt;% select(where(~ !all(is.na(.)))) cleaned_berry_data &lt;- raw_berry_data %&gt;% # Get the relevant columns select(`Subject Code`, berry, sample, starts_with(&quot;cata_&quot;), contains(&quot;overall&quot;)) %&gt;% # Rescale the LAM and US scales to a 9-pt range mutate(lms_overall = (lms_overall + 100) * (8 / 200) + 1, us_overall = (us_overall + 0) * (8 / 15) + 1) %&gt;% # Switch the 3 overall liking columns into a single column pivot_longer(contains(&quot;overall&quot;), names_to = &quot;hedonic_scale&quot;, values_to = &quot;rating&quot;, values_drop_na = TRUE) %&gt;% # Let&#39;s make all the CATA variables into a single column to make life easier # (and get rid of those NAs) pivot_longer(starts_with(&quot;cata_&quot;), names_to = &quot;cata_variable&quot;, values_to = &quot;checked&quot;, names_transform = ~str_remove(., &quot;cata_&quot;), values_drop_na = TRUE) berry_penalty_analysis_data &lt;- cleaned_berry_data %&gt;% group_by(berry, cata_variable, checked) %&gt;% summarize(rating = mean(rating), count = n()) %&gt;% pivot_wider(names_from = checked, values_from = c(rating, count), names_prefix = &quot;checked_&quot;) %&gt;% mutate(penalty_lift = rating_checked_1 - rating_checked_0, count = count_checked_1, .keep = &quot;none&quot;) %&gt;% ungroup() %&gt;% # We can tidy up our CATA labels separate(cata_variable, into = c(&quot;mode&quot;, &quot;variable&quot;), sep = &quot;_&quot;, remove = FALSE) %&gt;% # Fix a typo mutate(mode = str_replace(mode, &quot;appearane&quot;, &quot;appearance&quot;)) %&gt;% mutate(mode = case_when(mode == &quot;taste&quot; ~ &quot;(T)&quot;, mode == &quot;appearance&quot; ~ &quot;(A)&quot;)) %&gt;% unite(variable, mode, col = &quot;cata_variable_clean&quot;, sep = &quot; &quot;) p1_berry_penalty &lt;- berry_penalty_analysis_data %&gt;% # We are using a function from tidytext that makes faceting the final figure # easier mutate(cata_variable_clean = tidytext::reorder_within(x = cata_variable_clean, by = penalty_lift, within = berry)) %&gt;% #And finally we plot! ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + tidytext::scale_x_reordered() + coord_flip() + theme_classic() + scale_fill_gradient(low = &quot;tan&quot;, high = &quot;darkgreen&quot;) + labs(x = NULL, y = NULL, title = &quot;Penalty / Lift Analysis&quot;, subtitle = &quot;displays the mean difference (within berries) for when a CATA variable is checked\\nor un-checked&quot;) p1_berry_penalty 1.3.3 “Publication quality” What do we mean by “publication quality” visualizations? Neither of us are theorists of visualization–for that, we would recommend that you look at the excellent work from Claus Wilke and Kieran Healey. We will not be discussing (in any detail) ideas about which color palettes best communicate different types of data, what kinds of displays are most effective (box plots vs violin plots vs …), or whether pie charts are really so bad (mostly yes). Rather, we have noticed that most R packages for data analysis provide visualizations as part of their output, and many sensory scientists are using these default outputs in publications. This is annoying because often these visualizations are meant to be part of the data exploration/analysis process: they are not polished or they don’t display the data to its best advantage (whatever that is for the particular case). In this workshop, we want to help you develop the competency to alter or re-make these visualizations for yourself so that you can produce visualizations that are relevant to your application, that are attractive and easy to read. As an example, the FactoMineR package has excellent default visualizations for exploring and understanding the basic outputs of many common multivariate analyses used by sensory scientists. We can take a look at our cider CATA data visualized as a symmetric CA “biplot” without much effort: p3_cider_factominer &lt;- plot(ca_cider) p3_cider_factominer But there might be things about this we want to change! It would be very helpful to know, for example, that this is a ggplot2 object that can be altered by a basic handful of standardized syntax. For example: p3_cider_factominer + theme_dark() + labs(caption = &quot;Now we can say some more things!&quot;, subtitle = &quot;of 6 ciders tasted by 48 subjects&quot;) Like I said, we’re not here to tell you how your plots should look… Furthermore, default plots often do not allow us to do everything we want to do. Say we were very attached to the orange and green color scheme I used above, and wanted to use it in the nice plot from FactoMineR: p3_cider_factominer + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) Hmm. The motivating point, here, is to be able to make visualizations that accomplish what you want them to, rather than being at the mercy of packages that have certain defaults built in. 1.4 Saving your data Often, you will have an ugly, raw data file. You want to clean up this data file: remove junk variables, rename columns, omit outliers, and have something that is actually workable. Sometimes, you create a new intermediate product (say, a penalty-analysis table) that you’d like to be able to share and work with elsewhere. Now, you know how to do all that in R, often with fewer clicks and less effort than in Excel or other WYSIWYG tool. But once you restart your R session, you will need to rerun this workflow, and you can’t access your data products in other software. To save this work, you can use write.csv() or readr::write_csv() and its relatives (e.g., functions like write.file()). These will create or overwrite a file in the directory location you specify. # We will keep in the tidyverse idiom with readr::write_csv() write_csv(x = berry_penalty_analysis_data, file = &quot;data/berry-penalty-data.csv&quot;) Sometimes, we want to be able to save R data for re-loading later. It’s good to do this explicitly, rather than relying on something like RStudio’s version of autosaving (which we’ve turned off for you at the beginning of this tutorial). You might want to do this instead of write_csv() because: You have non-tabular data (lists, tensors, ggplots, etc) You are saving the output of time-consuming workflows and want to be able to start again without re-running those workflows You want to bundle a lot of objects together into a single file for yourself or other R users If you want to save a single R object, the write_rds() function saves an object into a native R data format: .rds. This uses syntax similar to write_csv(): berry_penalty_analysis_data %&gt;% write_rds(file = &quot;data/berry-penalty-data.rds&quot;) Often, though, it can be helpful to save multiple R objects so that a workplace can be restored. In this case, the generic save() function will save a list of R objects provided as symbolic names into a file of format .RData, which can be restored with load(). save(berry_penalty_analysis_data, ca_cider_coords, ca_cider, cider_contingency, file = &quot;data/workshop-data.RData&quot;) rm(berry_penalty_analysis_data, ca_cider_coords, ca_cider, cider_contingency) load(file = &quot;data/workshop-data.RData&quot;) This can be very helpful for sharing data. 1.4.1 A note on replicability In order to make sure that your data are replicable, you should always keep your raw data and the script/code that transforms that data into your cleaned form. That way, when (not if) you discover a couple minor errors, you can go back and fix them, and you will not be stuck trying to remember how you overwrote this data in the first place. This will also protect you if, in the future, someone looks at your data and asks something like “but where did these means come from?” 1.5 Wrap up This introductory section speeds over a large number of basic data-manipulation tasks that are key to any kind of analysis. To learn more, you can look into some of the resources we’ve linked here (in particular the R for Data Science handbook), some of our previous workshops on the topic, to see how these tools can be applied to sensory data, or my recently created R Opus v2, which applies these tools to a variety of common sensory analyses. "],["the-basics-of-plotting-with-ggplot2.html", "2 The basics of plotting with ggplot2 2.1 Your first ggplot() 2.2 The aes() function and mapping = argument 2.3 Adding layers with geom_*() functions 2.4 Arguments inside and outside of aes() 2.5 Some further reading", " 2 The basics of plotting with ggplot2 Base R includes extremely powerful utilities for data visualization, but most modern applications make use of the tidyverse package ggplot2. A quick word about base R plotting–I don’t mean to declare that you can’t use base R plotting for your projects at all, and I have published several papers using base R plots. Particularly as you are using R for your own data exploration (not meant for sharing outside your team, say), base utilities like plot() will be very useful for quick insight. ggplot2 provides a standardized, programmatic interface for data visualization, in contrast to the piecemeal approach common to base R graphics plotting. This means that, while the syntax itself can be challenging to learn, syntax for different tasks is linked by a common vocabulary, and differs in logical and predictable ways. Together with other tidyverse principles (like select() and filter() approaches), ggplot2 makes it easy to make publication-quality visualizations with relative ease. In general, ggplot2 works best with data in “long” or “tidy” format, such as that resulting from the output of pivot_longer(). The The schematic elements of a ggplot are as follows: # The ggplot() function creates your plotting environment. We usually save it to a variable in R so that we can use the plug-n-play functionality of ggplot without retyping a bunch of nonsense p &lt;- ggplot(mapping = aes(x = &lt;a variable&gt;, y = &lt;another variable&gt;, ...), data = &lt;your data&gt;) # Then, you can add various ways of plotting data to make different visualizations. p + geom_&lt;your chosen way of plotting&gt;(...) + theme_&lt;your chosen theme&gt; + ... In graphical form, the following diagram (from VT Professor JP Gannon) gives an intuition of what is happening: Basic ggplot mappings. Color boxes indicate where the elements go in the function and in the plot. 2.1 Your first ggplot() Our cider data is already relatively tidy and is much easier to visually inspect, so we will be primarily using it in this section. Let’s begin by making an example ggplot() to demonstrate how it works. We will focus on the cider CA coordinates so that we can build up a somewhat meaningful plot. # We start with our data and pipe it into ggplot ca_cider_coords %&gt;% # Here we set up the base plot ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + # Here we tell our base plot to add points geom_point() This doesn’t look all that impressive–partly because the data being plotted itself isn’t sensible without other context that exists in the data frame, and partly because we haven’t made many changes. But before we start looking into that, let’s break down the parts of this command. 2.2 The aes() function and mapping = argument The ggplot() function takes two arguments that are essential, as well as some others you’ll rarely use. The first, data =, is straightforward, and you’ll usually be passing data to the function at the end of some pipeline using %&gt;% The second, mapping =, is less clear. This argument requires the aes() function, which can be read as the “aesthetic” function. The way that this function works is quite complex, and really not worth digging into here, but I understand it in my head as telling ggplot() what part of my data is going to connect to what part of the plot. So, if we write aes(x =Dim 1), we can read this in our heads as “the values of x will be mapped from the ‘Dim 1’ column”. NB: The use of the \\`` character in`Dim 1`is because the name is technically \"non-syntactic\": it has a space in it.Rallows us to save objects with names that violate the rules--containing whitespace ( ), starting with a number character, or including characters like(,),$, etc by using the`operators. The{tidyverse}` functions do this automatically. This sentence tells us the other important thing about ggplot() and the aes() mappings: mapped variables each have to be in their own column. This is another reason that ggplot() requires tidy data. 2.3 Adding layers with geom_*() functions In the above example, we added (literally, using +) a function called geom_point() to the base ggplot() call. This is functionally a “layer” of our plot, that tells ggplot2 how to actually visualize the elements specified in the aes() function–in the case of geom_point(), we create a point for each row’s combination of x = MerlynScale_Ranking and y = Liking. ca_cider_coords %&gt;% select(`Dim 1`, `Dim 2`) ## # A tibble: 28 × 2 ## `Dim 1` `Dim 2` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.309 0.0232 ## 2 -0.331 0.0449 ## 3 0.0151 -0.165 ## 4 0.192 -0.193 ## 5 0.225 0.137 ## 6 0.201 0.147 ## 7 -0.303 0.0826 ## 8 0.0514 -0.111 ## 9 0.280 0.0580 ## 10 0.0907 -0.0946 ## # ℹ 18 more rows There are many geom_*() functions in ggplot2, and many others defined in other accessory packages. These are the heart of visualizations. We can swap them out to get different results: ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + # connecting our points with a line makes even less sense geom_line() The default geom_line() behavior is to connect points ordered by the column that is assigned to x = in the aes() function. We can also combine layers, as the term “layer” implies: ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point() + # add a layer with the names of the points geom_text(mapping = aes(label = name)) Note that we don’t need to tell either geom_point() or geom_text() what x and y are–they “inherit” them from the ggplot() function to which they are added (+), which defines the plot itself. But we did need to give a new mapping–label = name–to the geom_text() layer, which tells it which column to get the labels for each point. What other arguments can be set to aesthetics? Well, we can set other visual properties like color, size, transparency (called “alpha”), and so on. Let’s go ahead and color the different points and labels by whether they are ciders or CATA descriptors–whether they are rows or columns in the original contingency table. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point() + geom_text(mapping = aes(label = name)) Notice again that we don’t have to specify our color inside each label–because we define this “aesthetic” at the level of the plot in the ggplot() function all layers that can use it will “inherit” it. If we want to only color a single layer, we have a couple options. The simplest is simply to define the mapping only at the layer level, not the plot level. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + # we will only color the points, not the text geom_point(mapping = aes(color = type)) + geom_text(mapping = aes(label = name)) 2.4 Arguments inside and outside of aes() In the above plots, we are obviously unhappy with the position of the text in regards to the points: we are overplotting! What if we wanted to move our text so that it’s not centered on the \\((x,y)\\) point? (We will see a better way to do this automatically later.) ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + geom_text(mapping = aes(label = name), hjust = &quot;outward&quot;, color = &quot;darkblue&quot;) Here we set two aesthetics that could be in the aes() function and tied to data, but that we want to only set to a single value: we want all of our text to be \"darkblue\" (sure, why not?) and we use the hjust = \"outward\" text alignment option to push our text away from the center of the plot and thus not to overplot our points. Here I will also note that manual text adjustment is usually not the best approach with text-heavy scatterplots such as are common in sensory science biplots. We will usually prefer to use an automatic approach for adjusting text position from the {ggrepel} package. We can either load {ggrepel} directly using library(ggrepel) or we can use the :: syntax to access an installed function without loading the entire namespace. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + # here we opt for not loading the package ggrepel::geom_text_repel(mapping = aes(label = name), color = &quot;darkblue&quot;) + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) 2.4.1 Using theme_*() to change visual options quickly In the last several plots, notice that we are using the default (and to my mind unattractive) grey background of ggplot2. If this tutorial had a single goal, it would be to eliminate this theme from published papers. It looks bad (and tends to reduce contrast). ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + ggrepel::geom_text_repel(mapping = aes(label = name), color = &quot;darkblue&quot;) + # here we switch to a black and white theme theme_bw() We can easily get rid of the grey by adding a theme_bw() call to the list of commands. ggplot2 includes a number of default theme_*() functions, and you can get many more through other R packages. They can have subtle to dramatic effects: ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + ggrepel::geom_text_repel(mapping = aes(label = name), color = &quot;darkblue&quot;) + theme_void() The theme_*() functions are complete sets of plot background options. You can edit every last element of the plot’s theme using the base theme() function, which is powerful but a little bit tricky to use. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + ggrepel::geom_text_repel(mapping = aes(label = name), color = &quot;darkblue&quot;) + theme_bw() + # we use theme() to remove grid lines and move the legend, for example theme(panel.grid = element_blank(), legend.position = &quot;bottom&quot;) You can see a nearly-full list of the arguments to ggplot2::theme() in the theme help files (?theme), unlike with ggplot2 aesthetics and the geom_*() help files. Many calls to theme() involve element_*() functions. When we remove elements, for example, we use element_blank() (not, for example, NA or NULL as we typically would in other parts of R). When we want to change how our text is formatted (not the values, but the formatting), we use element_text() calls. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + ggrepel::geom_text_repel(mapping = aes(label = name), color = &quot;darkblue&quot;) + theme_bw() + # let&#39;s make the axis titles bold and the labels serif-font theme(axis.title = element_text(face = &quot;bold&quot;), axis.text = element_text(family = &quot;serif&quot;)) Finally, we can set default themes for a particular script using the theme_set() function. We can also use this to set custom defaults: theme_set( theme_bw() + theme(panel.grid.minor = element_blank()) ) ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`)) + geom_point(mapping = aes(color = type)) + ggrepel::geom_text_repel(mapping = aes(label = name), color = &quot;darkblue&quot;) All plots from here on in the script will default to the theme_bw() theme, with the “minor” grid lines removed for a cleaner grid look. 2.4.2 Changing aesthetic elements with scale_*() functions Finally, say we didn’t like the default color set for the points. How can we manipulate the colors that are plotted? The way in which mapped, aesthetic variables are assigned to visual elements is controlled by the scale_*() functions. In my experience, the most frequently encountered scales are those for color: either scale_fill_*() for solid objects (like the bars in a histogram) or scale_color_*() for lines and points (like the outlines of the histogram bars, or the points and letters in our scatterplots so far). Scale functions work by telling ggplot() how to map aesthetic variables to visual elements. You may have noticed that I added a scale_color_manual() function to the end of several plots above. This function lets me manually specify the colors that are assigned to each colored element. p &lt;- ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point() + ggrepel::geom_text_repel(mapping = aes(label = name), # this command stops this layer from being added to # the legend, to make it look cleaner show.legend = FALSE) p We can take a saved plot (like p) and use scales to change how it is visualized. p + scale_color_viridis_d() ggplot2 has a broad range of built-in options for scales, but there are many others available in add-on packages that build on top of it. The scale_*_viridis_*() functions use a package callled viridis that provides (theoretically) color-blind safe colors for both continuous (gradient) and categorical (discrete) mappings, but I do find that their defaults (using light colors like yellow on one end of the scale) are hard to see for anyone! As we saw above, you can also build your own scales using the scale_*_manual() functions, in which you give a vector of the same length as your mapped aesthetic variable in order to set up the visual assignment. That sounds jargon-y, so here is an example: # We&#39;ll pick 14 random colors from the colors R knows about p + scale_color_manual(values = c(&quot;wheat&quot;, &quot;darkviolet&quot;)) 2.4.3 Finally, facet_*() So far we’ve seen how to visualize the overall configuration of our ciders by their CATA attributes using a Correspondence Analysis. These results are, of course, based on an underlying contingency table: cider_contingency ## Fresh_Apples Fermented Herbal Dry Spice Fruity Smooth Alcohol ## 1911 Est. Chilled 29 12 4 16 10 24 15 19 ## 1911 Est. RT 27 17 7 15 5 25 18 13 ## Buskey Chilled 19 22 8 22 9 15 15 19 ## Buskey RT 11 18 10 21 12 14 14 21 ## Eden Chilled 16 14 13 20 9 13 9 17 ## Eden RT 17 18 10 17 7 16 7 21 ## Light Sweet Woody Berries Sour Funky FullBodied Metallic ## 1911 Est. Chilled 19 16 2 4 20 1 4 5 ## 1911 Est. RT 17 25 6 8 23 2 8 4 ## Buskey Chilled 20 19 5 4 14 10 5 4 ## Buskey RT 16 18 7 2 14 10 8 2 ## Eden Chilled 11 14 8 2 24 12 5 9 ## Eden RT 13 15 12 4 23 12 5 7 ## Floral Candy Bitter Vomit Earthy Synthetic ## 1911 Est. Chilled 8 6 10 2 3 3 ## 1911 Est. RT 10 6 7 1 2 3 ## Buskey Chilled 13 1 12 1 5 3 ## Buskey RT 9 0 13 5 9 4 ## Eden Chilled 11 3 13 5 9 7 ## Eden RT 11 1 13 3 6 10 A natural visualization to quickly assess CATA results is of course a bar plot. cider_contingency %&gt;% as_tibble(rownames = &quot;sample&quot;) %&gt;% pivot_longer(-sample) %&gt;% ggplot(mapping = aes(x = name, y = value, fill = sample)) + geom_col(position = &quot;dodge&quot;) + labs(x = NULL, y = NULL) + # coord_*() functions affect how the axes are plotted; # coord_flip() switches the x- and y-axes coord_flip() This is obviously not ideal for visualization: It is hard to see the bars. CA plots are driven by ratios, so it would be good to see differences based on rates of endorsement for CATA per-attribute, not overall (common attributes swamp uncommon attributes). The last powerful tool I want to show off is the ability of ggplot2 to make what Edward Tufte called “small multiples”: breaking out the data into multiple, identical plots by some categorical classifier in order to show trends more effectively. cider_contingency %&gt;% as_tibble(rownames = &quot;sample&quot;) %&gt;% pivot_longer(-sample) %&gt;% ggplot(aes(x = sample, y = value)) + geom_col(aes(fill = sample)) + scale_fill_manual(values = wesanderson::wes_palettes$AsteroidCity2) + coord_flip() + facet_wrap(~name, ncol = 6) + labs(x = NULL, y = NULL, fill = NULL) + theme(legend.position = &quot;top&quot;) We can see that overall for the most frequently used attributes, the serving temperature doesn’t matter (and for the most part there is some reassuring consistency in the use of terms to describe each cider at different temperatures). But in the previous part of this workshop, we showed much more complex plots for our berry data, which showed the same plot broken up by a classifying variable: this is called “faceting”. Let’s return from our cider data to our berry data in order to finally complete the workflow I showed in the beginning of the workshop. Now we are prepared to walk through the entire workflow: p1_berry_penalty &lt;- berry_penalty_analysis_data %&gt;% # We are using a function from tidytext that makes faceting the final figure # easier: reorder_within() makes a set of factors able to be ordered # differently within another variable. In this case, we have different # attributes and different penalties within each berry by design mutate(cata_variable_clean = tidytext::reorder_within(x = cata_variable_clean, by = penalty_lift, within = berry)) %&gt;% #And finally we plot! ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + # To take advantage of our newly reordered factors, we also need to use the # matching tidytext::scale_x_reordered() function tidytext::scale_x_reordered() + coord_flip() + theme_classic() + scale_fill_gradient(low = &quot;tan&quot;, high = &quot;darkgreen&quot;) + labs(x = NULL, y = NULL, title = &quot;Penalty / Lift Analysis&quot;, subtitle = &quot;displays the mean difference (within berries) for when a CATA variable is checked&quot;) p1_berry_penalty We can see that the 2 most important attributes for driving liking are the same across all 4 berries, but that the highest penalty is different across them. # First, we have some string-wrangling to do so that our various labels are # more descriptive and seem like a person wrote them, rather than a computer. nice_cider_labels &lt;- labs(x = str_c(&quot;Dimension 1, &quot;, round(ca_cider$eig[1, 2], 1), &quot;% of inertia&quot;), y = str_c(&quot;Dimension 2, &quot;, round(ca_cider$eig[2, 2], 1), &quot;% of inertia&quot;), subtitle = &quot;Correspondence Analysis biplot (symmetric)&quot;, title = &quot;Effect of cider serving temperature on consumer sensory perception&quot;) p2_ca_cider_cata &lt;- ca_cider_coords %&gt;% # A few specific aesthetics don&#39;t have scale_*() functions and require that # you make a column with the exact names of the &quot;value&quot;. Fontface is one of them. mutate(font = if_else(type == &quot;row&quot;, &quot;plain&quot;, &quot;italic&quot;)) %&gt;% # And now we plot! ggplot(aes(x = `Dim 1`, y = `Dim 2`)) + # We can use geoms to make darker lines at the origin of each axis. # This goes first so that all of our data points are drawn on top. geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, color = &quot;darkgrey&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;darkgrey&quot;) + # We want to represent our samples with geom_point and our attributes # with geom_text, so we need to do some creative filtering. geom_point(aes(color = type, shape = Temperature), data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;), size = 3) + ggrepel::geom_text_repel(aes(label = name, color = type, fontface = font), show.legend = FALSE) + # and now we do our fine-tuning. coord_equal() + theme_linedraw() + theme(legend.position = &quot;bottom&quot;) + nice_cider_labels + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) + scale_shape_manual(values = c(8, 16)) + guides(shape = guide_legend(), color = &quot;none&quot;) p2_ca_cider_cata # Let&#39;s save them so we can come back to them later: save(p1_berry_penalty, p2_ca_cider_cata, file = &quot;data/goal-plots.RData&quot;) 2.5 Some further reading This has been a lightning tour of ggplot2 as preparatory material; it barely scratches the surface. We’re going to dig into some further tools that you can use for common sensory visualizations, but we’ve learned all of these tricks from the following resources (as well as a lot of work on Stack Overflow/Exchange): Kieran Healy’s “Data Visualization: a Practical Introduction”. The plotting section of R for Data Science. Hadley Wickham’s core reference textbook on ggplot2. "],["fine-tuning-publication-quality-ggplots.html", "3 Fine-Tuning Publication-Quality ggplots 3.1 Exporting and Saving Plots 3.2 Fine-tuning bar plots &amp; facets with different categorical variables 3.3 Fine-tuning biplots with different types of variables", " 3 Fine-Tuning Publication-Quality ggplots The plots we’ve been making so far are fairly straightforward demonstrations. At the very end of Chapter 2, we briefly showed you the code and results for these two plots: p1_berry_penalty p2_ca_cider_cata We’re going to spend the rest of the workshop running through the tips and tricks we used to make these look polished. It’s not an exhaustive list of the things you can change or tweak, though, so more than anything, we hope you walk away with the ability to identify what parts of a plot you want to change and the skills to figure out how to change it. But first, something that everyone will need for almost every plot: 3.1 Exporting and Saving Plots It may seem like a weird time to be talking about saving plots, when we haven’t gotten to the “fine-tuning” yet, but you’ve already seen a few examples of things that change when the aspect ratio of the plot or the monitor you’re viewing it on changes slightly. It is basically impossible to export a ggplot at the resolution needed for publishing without changing the aspect ratio, relative sizes, or space between some elements from what you’re looking at in the Plots pane or the .Rmd chunk output. It’s good practice to export your plot as an image (or pdf or knit-together document or however else you plan to export it) and re-export it periodically as you go through fine-tuning. This is also, probably, the most important part of this chapter. You will have to get every plot that you publish out of R somehow, after all! Exporting Images with ggsave() You can, as we’ve already discussed, save a ggplot object in a .rds file. But that won’t let you put it into your powerpoint, or manuscript, or take it to the printer. You need an image file. The exact type of image will depend on the other software you’re using for your report, presentation, paper, book, etc. The easiest way to reproducibly save plots, so that all of your export options are in your code and you might be able to recreate it on a different computer, is with the function ggplot2::ggsave(), which works similarly to the write_*() functions and save(). You give it a file name to save to, relative to the current working directory, and then the variable that has your ggplot. ggsave(&quot;img/penalty-lift.jpeg&quot;, p1_berry_penalty) We saved our image as a JPEG file, because JPEG is one of the formats preferred by Food Quality and Preference. ggsave() supports a wide variety of image formats and will automatically use the file type corresponding to the file extension (the stuff after the .) in the filename argument. Note that ggsave() is like making a .pdf version of your working documents: you will not be able to read the plot images into R for editing anymore, no matter which format you save in. We can also specify the width and height of our plot in inches, centimeters, or several other possible units. Aside from the aspect ratio of height to width, the size also affects how large various elements look, since geom_*() and text sizes are ultimately defined as fractions of inches. Start by exporting your file at different width and height combinations until it looks legible, with readable text and other elements. ggsave(&quot;img/penalty-lift-10x6.jpeg&quot;, p1_berry_penalty, width = 10, height = 6, units = &quot;in&quot;) #inches And then figure out the dpi, or number of dots per inch, needed to have a file that will print well. Do not just use the DPI you want to print at, especially if you’re planning to use an image for a poster. The FQAP Guide for Authors also tells us that it wants “combination figures”, which will include most graphs, at or above 500 dpi. A double column figure is about 7.5 inches or 190mm wide, so we need the image to be \\(7.5 \\times 500 = 3750\\) pixels wide. Since our nice plot had width = 10, we’ll set the dpi so that \\(height \\times dpi \\geq 3750\\). ggsave(&quot;img/penalty-lift-double-column-width.jpeg&quot;, p1_berry_penalty, width = 10, height = 6, units = &quot;in&quot;, #inches dpi = 400) #slightly above 3750 / 10. Always err on the side of slightly too big!! We go into a lot more detail on common file types and image resolution math in the Appendix. 3.2 Fine-tuning bar plots &amp; facets with different categorical variables We’ll start with the penalty analysis plot. p1_berry_penalty uses some tricks from the stringr and tidytext packages in order to give us easy-to-read labels. Using the existing column names and variable-codes in our original data to make a first draft of a plot, it would’ve looked more like this: berry_penalty_analysis_data %&gt;% ggplot(mapping = aes(x = cata_variable, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry) + theme_classic() + theme(axis.text.x = element_text(angle = 90)) Which we’re showing because we have seen similar plots published in journal articles, with the difficult-to-read axes, underscores, redundant axis labels, and all. We can make this more readable by reordering the CATA attributes, shortening and reformatting the labels, and possibly by removing some extraneous elements like the cata_variable label. These are common steps that make a huge difference. 3.2.1 Horizontal text with coord_flip() We’ve used coord_flip() a few times already, and it’s pretty straightforward to use–you just have to add it to a ggplot() call and it’ll make your x axis the vertical axis and your y axis the horizontal. berry_penalty_analysis_data %&gt;% ggplot(mapping = aes(x = cata_variable, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, nrow = 1) + theme_classic() + coord_flip() Even though the CATA attributes are still cramped and this isn’t the best use of space, they’re much easier to read now. If you’ve only got one categorical axis, it’s almost always going to be more readable to have it be the vertical axis so that the text is horizontal. 3.2.2 Ordered Categorical Variables Many of the figures we’ve made so far have had an axis with a categorical variable. Have you figured out how ggplot2 orders the levels of categorical variables? If you have noticed, it’s likely because it’s in a different order than the one we’d like. berry_penalty_analysis_data %&gt;% ggplot(mapping = aes(x = cata_variable, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, nrow = 1) + coord_flip() + theme_classic() The CATA attributes are in alphabetical order (with the start of the alphabet the closest to 0). This is how ggplot2 treats all character variables, and you can exert some control over the ordering by turning the variable into an ordered factor. 3.2.2.1 Specifying Ordinal Variables as Factors You can order variables by hand, if there’s a particular order you have in mind: berry_penalty_analysis_data %&gt;% filter(str_detect(cata_variable, &quot;taste&quot;)) %&gt;% mutate(cata_variable = factor(cata_variable, levels = c(&quot;taste_fruity&quot;, &quot;taste_melon&quot;, &quot;taste_peachy&quot;, &quot;taste_grapey&quot;, &quot;taste_grape&quot;, &quot;taste_berry&quot;, &quot;taste_cherry&quot;, &quot;taste_citrus&quot;, &quot;taste_lemon&quot;, &quot;taste_tropical&quot;, &quot;taste_candy&quot;, &quot;taste_caramel&quot;, &quot;taste_green&quot;, &quot;taste_grassy&quot;, &quot;taste_piney&quot;, &quot;taste_minty&quot;, &quot;taste_earthy&quot;, &quot;taste_fermented&quot;, &quot;taste_cinnamon&quot;, &quot;taste_clove&quot;, &quot;taste_floral&quot;, &quot;taste_none&quot;))) -&gt; berry_penalty_manual_factors berry_penalty_manual_factors %&gt;% ggplot(mapping = aes(x = cata_variable, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, nrow = 1) + coord_flip() + theme_classic() Note that the attribute you list first when you’re specifying the levels will become 1, then 2, then 3. With coord_flip(), that puts it at the bottom of the plot. berry_penalty_manual_factors %&gt;% distinct(cata_variable) %&gt;% mutate(variable_number = as.numeric(cata_variable)) ## # A tibble: 22 × 2 ## cata_variable variable_number ## &lt;fct&gt; &lt;dbl&gt; ## 1 taste_berry 6 ## 2 taste_cinnamon 19 ## 3 taste_clove 20 ## 4 taste_earthy 17 ## 5 taste_fermented 18 ## 6 taste_floral 21 ## 7 taste_fruity 1 ## 8 taste_grape 5 ## 9 taste_grassy 14 ## 10 taste_lemon 9 ## # ℹ 12 more rows This gives us control, but it’s pretty annoying to write out for large lists of attributes, and you have to be sure the spelling and capitalization match exactly. Often, like with the penalty analysis plots, what we actually want to do is order the Attributes in terms of some other numerical variable, like frequency or size of penalty. One way is to arrange() the data the way you want it and then use that order to specify the levels. berry_penalty_analysis_data %&gt;% # Counting the number of times each attribute is used across all products: group_by(cata_variable) %&gt;% mutate(variable_count = sum(count)) %&gt;% ungroup() %&gt;% # Arranging from least-to-most used: arrange(variable_count) %&gt;% # Converting to a factor, so the least-used will be 1st, then the next: mutate(cata_variable = factor(cata_variable, levels = unique(cata_variable), ordered = TRUE), variable_number = as.numeric(cata_variable)) -&gt; berry_penalty_frequency_factors #Now the plot: berry_penalty_frequency_factors %&gt;% ggplot(mapping = aes(x = cata_variable, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, nrow = 1) + coord_flip() + theme_classic() 3.2.2.2 Facets with Different Category-Orders You’ll notice that our reordered categorical axes still have the same order across all of the plots. This would be true even if we used the within-product sums already in the count column to calculate levels. The order is based on factor levels, which are fixed within each column: Fresh_Apples can’t be “more than” Dry in one part of the cata_variable column and “less than” in another part. On its own, facet_wrap(..., scales = \"free\") can drop unneeded attributes from plots, but it will still keep the same order of the attributes across all axes. berry_penalty_frequency_factors %&gt;% ggplot(mapping = aes(x = cata_variable, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + facet_wrap(~berry, nrow = 1) + coord_flip() + theme_classic() If you have a faceted plot and you want each facet to have a different ordering of the terms, like in our big penalty analysis example, you’ll have to use tidytext::reorder_within(), tidytext::scale_*_reordered(), and facet_wrap(..., scales = \"free\"), all at once: berry_penalty_analysis_data %&gt;% mutate(cata_variable_clean = tidytext::reorder_within(cata_variable_clean, by = count, within = berry)) %&gt;% ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;, show.legend = FALSE) + tidytext::scale_x_reordered() + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + coord_flip() + theme_classic() 3.2.3 Making labels look okay: Powerful text manipulation with stringr A good R variable or column name doesn’t have any spaces or punctuation other than underscores (_) and dots (.), to avoid all those pesky backticks (```) in our code. This is very different from what a good label in a plot looks like. You’ll often want to make some sort of mass changes to column names or text variables before plotting, in order to address this. The stringr package is a part of the tidyverse, so you have it already loaded whenever you run library(tidyverse). It has a lot of useful functions for working with text (called “strings” in many programming languages), mostly of the form str_*(). One thing you can do is change labels to uppercase, lowercase, “sentence case”, or “title case” (first letter of each word capitalized), as appropriate: berry_penalty_analysis_data %&gt;% select(berry) %&gt;% mutate(Upper = str_to_upper(berry), Title = str_to_title(berry)) # Capitalizes the first letter of each word ## # A tibble: 85 × 3 ## berry Upper Title ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 blackberry BLACKBERRY Blackberry ## 2 blackberry BLACKBERRY Blackberry ## 3 blackberry BLACKBERRY Blackberry ## 4 blackberry BLACKBERRY Blackberry ## 5 blackberry BLACKBERRY Blackberry ## 6 blackberry BLACKBERRY Blackberry ## 7 blackberry BLACKBERRY Blackberry ## 8 blackberry BLACKBERRY Blackberry ## 9 blackberry BLACKBERRY Blackberry ## 10 blackberry BLACKBERRY Blackberry ## # ℹ 75 more rows 3.2.3.1 Replacing text str_replace() and str_replace_all() are very useful for dealing with underscores or periods. You give it string, the text vector you want to modify (inside mutate(), a column name); then pattern, the character(s) you want to replace; then replacement, what you want to replace them with. berry_penalty_analysis_data %&gt;% mutate(cata_variable = str_replace_all(cata_variable, &quot;_&quot;, &quot;: &quot;)) ## # A tibble: 85 × 5 ## berry cata_variable cata_variable_clean penalty_lift count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 blackberry appearance: fresh fresh (A) 1.10 977 ## 2 blackberry appearance: goodcolor goodcolor (A) 1.14 1037 ## 3 blackberry appearance: goodquality goodquality (A) 1.26 859 ## 4 blackberry appearance: goodshapre goodshapre (A) 0.923 787 ## 5 blackberry appearance: misshapen misshapen (A) -0.708 447 ## 6 blackberry appearance: none none (A) -0.641 13 ## 7 blackberry appearance: notfresh notfresh (A) -1.81 127 ## 8 blackberry appearance: unevencolor unevencolor (A) -0.998 163 ## 9 blackberry appearane: bruised bruised (A) -0.861 190 ## 10 blackberry taste: berry berry (T) 2.27 793 ## # ℹ 75 more rows They can both be as long as you like. If pattern = _ and there’s more than one _ in one of the strings, str_replace() will only replace the first one and str_replace_all() will replace them all. str_replace(&quot;long_text_with_many_underscores&quot;, &quot;_&quot;, &quot; &quot;) ## [1] &quot;long text_with_many_underscores&quot; str_replace_all(&quot;long_text_with_many_underscores&quot;, &quot;_&quot;, &quot; &quot;) ## [1] &quot;long text with many underscores&quot; You can add multiple sets of patterns and replacements to str_replace_all() using a named list: c(\"pattern1\" = \"replace1\", \"pattern2\" = \"replace2\". This is useful to, for instance, fix multiple typos like “goodshapre”. Unlike the case_when() example we showed before, you can fix typos that occur anywhere in the text, even if they’re only parts of a word. berry_penalty_analysis_data %&gt;% mutate(cata_variable = str_replace_all(cata_variable, c(&quot;shapre&quot; = &quot;shape&quot;, &quot;appearane&quot; = &quot;appearance&quot;, &quot;_&quot; = &quot; &quot;))) ## # A tibble: 85 × 5 ## berry cata_variable cata_variable_clean penalty_lift count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 blackberry appearance fresh fresh (A) 1.10 977 ## 2 blackberry appearance goodcolor goodcolor (A) 1.14 1037 ## 3 blackberry appearance goodquality goodquality (A) 1.26 859 ## 4 blackberry appearance goodshape goodshapre (A) 0.923 787 ## 5 blackberry appearance misshapen misshapen (A) -0.708 447 ## 6 blackberry appearance none none (A) -0.641 13 ## 7 blackberry appearance notfresh notfresh (A) -1.81 127 ## 8 blackberry appearance unevencolor unevencolor (A) -0.998 163 ## 9 blackberry appearance bruised bruised (A) -0.861 190 ## 10 blackberry taste berry berry (T) 2.27 793 ## # ℹ 75 more rows Be careful using short patterns, because they will replace every example even if it’s only part of a word. #This can lead to unintentional side-effects c(&quot;nocolor&quot;, &quot;none&quot;, &quot;cornonthecob&quot;, &quot;anode&quot;) %&gt;% str_replace_all(&quot;no&quot;, &quot; NO &quot;) ## [1] &quot; NO color&quot; &quot; NO ne&quot; &quot;cor NO nthecob&quot; &quot;a NO de&quot; #Or it can be useful for fixing lots of similar problems all at once berry_penalty_analysis_data %&gt;% mutate(cata_variable = str_replace_all(cata_variable, c(&quot;not&quot; = &quot;not &quot;, &quot;good&quot; = &quot;good &quot;, &quot;uneven&quot; = &quot;uneven &quot;, &quot;_&quot; = &quot; &quot;))) ## # A tibble: 85 × 5 ## berry cata_variable cata_variable_clean penalty_lift count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 blackberry appearance fresh fresh (A) 1.10 977 ## 2 blackberry appearance good color goodcolor (A) 1.14 1037 ## 3 blackberry appearance good quality goodquality (A) 1.26 859 ## 4 blackberry appearance good shapre goodshapre (A) 0.923 787 ## 5 blackberry appearance misshapen misshapen (A) -0.708 447 ## 6 blackberry appearance none none (A) -0.641 13 ## 7 blackberry appearance not fresh notfresh (A) -1.81 127 ## 8 blackberry appearance uneven color unevencolor (A) -0.998 163 ## 9 blackberry appearane bruised bruised (A) -0.861 190 ## 10 blackberry taste berry berry (T) 2.27 793 ## # ℹ 75 more rows So far, we’ve been replacing letters and underscores, which is what we have in our example data. You can also use str_replace() for periods (.), although you may be surprised when you first try: str_replace_all(&quot;long.text.with.many.periods&quot;, &quot;.&quot;, &quot; &quot;) # Replaces everything ## [1] &quot; &quot; str_replace_all(&quot;long.text.with.many.periods&quot;, &quot;\\\\.&quot;, &quot; &quot;) # Replaces only dots ## [1] &quot;long text with many periods&quot; We have to escape the period (with an escaped backslash, technically, but for now just know that you must put two backslashes \\\\ before special characters when using stringr). Because the str_* functions with a pattern can use Regular Expressions (or regex), the characters (\\, ., [, ], {, }, (, ), &lt;, &gt;, *, +, -, =, !, ?, ^, $, and |) need to be escaped with two backslashes if you need to replace them. Regex are extremely powerful tools for finding patterns in text, similar to the intuitive ways a human might recognize something like an email address, a measurement, or a parenthetical. We will not be talking about regex today, but if you want to see some examples and resources for learning how to use them, we’ve provided a short overview and links to some resources in the Appendix. 3.2.3.2 Splitting and combining text It’s also very common that you may have variable names in one column which actually represent multiple variables, and may want to, say, color-code the modality of the cata variables so that appearance attributes are one color and taste attributes are another. There are a few versions of the tidyr::separate_wider_*() function that can, for example, split the cata_variable column into two columns, one with everything before the delimiter (here, an underscore) and one with everything after the delimiter. Be very careful using separate_wider_delim() like this if some rows may have more underscores (or whatever your delimiter is) than others. berry_penalty_by_modality &lt;- berry_penalty_analysis_data %&gt;% separate_wider_delim(cata_variable, &quot;_&quot;, names = c(&quot;mode&quot;, &quot;variable&quot;), cols_remove = FALSE) berry_penalty_by_modality ## # A tibble: 85 × 7 ## berry mode variable cata_variable cata_variable_clean penalty_lift count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 blackber… appe… fresh appearance_f… fresh (A) 1.10 977 ## 2 blackber… appe… goodcol… appearance_g… goodcolor (A) 1.14 1037 ## 3 blackber… appe… goodqua… appearance_g… goodquality (A) 1.26 859 ## 4 blackber… appe… goodsha… appearance_g… goodshapre (A) 0.923 787 ## 5 blackber… appe… misshap… appearance_m… misshapen (A) -0.708 447 ## 6 blackber… appe… none appearance_n… none (A) -0.641 13 ## 7 blackber… appe… notfresh appearance_n… notfresh (A) -1.81 127 ## 8 blackber… appe… unevenc… appearance_u… unevencolor (A) -0.998 163 ## 9 blackber… appe… bruised appearane_br… bruised (A) -0.861 190 ## 10 blackber… taste berry taste_berry berry (T) 2.27 793 ## # ℹ 75 more rows # Which would let you easily color-code your ggplot based on the new mode column berry_penalty_by_modality %&gt;% ggplot(aes(x = cata_variable, y = count, fill = mode)) + geom_col() + coord_flip() (We’ll get to the typo in just a second–you already know how to fix it, though!) If you want to put multiple columns of text together, you can use either tidyr::unite() or stringr::str_c() (string combine). berry_penalty_by_modality %&gt;% mutate(cata_variable_2 = str_c(variable, mode, sep = &quot; &quot;)) %&gt;% unite(variable, mode, col = &quot;cata_variable_3&quot;, sep = &quot; &quot;) ## # A tibble: 85 × 7 ## berry cata_variable_3 cata_variable cata_variable_clean penalty_lift count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 blackbe… fresh appearan… appearance_f… fresh (A) 1.10 977 ## 2 blackbe… goodcolor appe… appearance_g… goodcolor (A) 1.14 1037 ## 3 blackbe… goodquality ap… appearance_g… goodquality (A) 1.26 859 ## 4 blackbe… goodshapre app… appearance_g… goodshapre (A) 0.923 787 ## 5 blackbe… misshapen appe… appearance_m… misshapen (A) -0.708 447 ## 6 blackbe… none appearance appearance_n… none (A) -0.641 13 ## 7 blackbe… notfresh appea… appearance_n… notfresh (A) -1.81 127 ## 8 blackbe… unevencolor ap… appearance_u… unevencolor (A) -0.998 163 ## 9 blackbe… bruised appear… appearane_br… bruised (A) -0.861 190 ## 10 blackbe… berry taste taste_berry berry (T) 2.27 793 ## # ℹ 75 more rows ## # ℹ 1 more variable: cata_variable_2 &lt;chr&gt; You may have noticed that berry_penalty_analysis_data has both cata_variable and cata_variable_clean, and that the latter is shorter, which fits better on the page. You now know all of the tricks that we used to get from one to the other: berry_penalty_analysis_data %&gt;% # Fixing typos mutate(cata_variable = str_replace_all(cata_variable, c(&quot;appearane&quot; = &quot;appearance&quot;, &quot;shapre&quot; = &quot;shape&quot;))) %&gt;% # Separating the modality from the attribute name separate_wider_delim(cata_variable, &quot;_&quot;, names = c(&quot;mode&quot;, &quot;variable&quot;), cols_remove = FALSE) %&gt;% # Shorthand for the taste and appearance variables mutate(mode = case_when(mode == &quot;taste&quot; ~ &quot;(T)&quot;, mode == &quot;appearance&quot; ~ &quot;(A)&quot;)) %&gt;% # Putting them back together unite(variable, mode, col = &quot;cata_variable_clean&quot;, sep = &quot; &quot;) ## # A tibble: 85 × 5 ## berry cata_variable_clean cata_variable penalty_lift count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 blackberry fresh (A) appearance_fresh 1.10 977 ## 2 blackberry goodcolor (A) appearance_goodcolor 1.14 1037 ## 3 blackberry goodquality (A) appearance_goodquality 1.26 859 ## 4 blackberry goodshape (A) appearance_goodshape 0.923 787 ## 5 blackberry misshapen (A) appearance_misshapen -0.708 447 ## 6 blackberry none (A) appearance_none -0.641 13 ## 7 blackberry notfresh (A) appearance_notfresh -1.81 127 ## 8 blackberry unevencolor (A) appearance_unevencolor -0.998 163 ## 9 blackberry bruised (A) appearance_bruised -0.861 190 ## 10 blackberry berry (T) taste_berry 2.27 793 ## # ℹ 75 more rows 3.2.4 Removing Plot Elements Plots are easiest to read when they have only the information that’s actually relevant, so some labels and other elements that ggplot2 adds by default can end up being extraneous and distracting. We covered using theme() to remove elements with element_blank() (e.g., + theme(panel.grid = element_blank()) to get rid of the grid lines), but there are some exceptions to this rule. When we’re using tidytext::reorder_within() to order each individual facet from highest penalty to highest lift, any color-coding for the lift is redundant info and we don’t really need a legend to spell it out: berry_penalty_analysis_data %&gt;% mutate(cata_variable_clean = tidytext::reorder_within(x = cata_variable_clean, by = penalty_lift, within = berry)) %&gt;% ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;) + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + coord_flip() + tidytext::scale_x_reordered() We also don’t really need the axis labels, since neither has units and anyone unfamiliar with a penalty-lift plot will need more explanation than an axis label can really provide, but cata_variable_clean is especially redundant. berry_penalty_analysis_data %&gt;% mutate(cata_variable_clean = tidytext::reorder_within(x = cata_variable_clean, by = penalty_lift, within = berry)) %&gt;% ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;) + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + coord_flip() + tidytext::scale_x_reordered() + theme(axis.title.y = element_blank(), legend.position = &quot;none&quot;) We can remove these both with one call to theme(), but the axis title is removed with axis.title.y = element_blank() and the legend is removed with legend.position = \"none\". And, yes, that is axis.title.y, referring to the same cata_variable_clean axis that scale_x_reordered() is calling the x-axis. Some ggplot2 functions will always refer to whatever you specified in aes(x = ...) as the x-axis, while some will refer to the horizontal axis as the x-axis, meaning that coord_flip() can make things confusing. It’s not worth trying to memorize or find patterns–this is something you’ll have to tweak by trial and error. Sometimes, there are multiple ways of removing a plot element, and whichever one you remember is fine to use. One notable example that may save you some typing is the labs() function, which lets you label the x and y axes, the whole plot title, and so on with a slightly easier-to-remember interface than theme(). Setting any of the labs() arguments = NULL will remove it from the plot. berry_penalty_analysis_data %&gt;% mutate(cata_variable_clean = tidytext::reorder_within(x = cata_variable_clean, by = penalty_lift, within = berry)) %&gt;% ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;) + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + coord_flip() + tidytext::scale_x_reordered() + labs(x = NULL, y = &quot;Penalty&quot;, title = &quot;Penalty / Lift Analysis&quot;, subtitle = &quot;displays the mean difference (within berries) for when a CATA variable is checked&quot;) Note that, unlike theme(), labs(x = ...) refers to the same x as aes(x = ...). 3.2.5 Putting it all together Now, at long last, we’re ready to walk line-by-line through the example penalty analysis figure that we’ve just been copy-pasting so far in the workshop. berry_penalty_analysis_data %&gt;% mutate(cata_variable_clean = tidytext::reorder_within(x = cata_variable_clean, by = penalty_lift, within = berry)) %&gt;% ggplot(mapping = aes(x = cata_variable_clean, y = penalty_lift)) + geom_col(aes(fill = penalty_lift), color = &quot;white&quot;) + facet_wrap(~berry, scales = &quot;free&quot;, nrow = 1) + tidytext::scale_x_reordered() + coord_flip() + theme_classic() + scale_fill_gradient(low = &quot;tan&quot;, high = &quot;darkgreen&quot;) + labs(title = &quot;Penalty / Lift Analysis&quot;, subtitle = &quot;displays the mean difference (within berries) for when a CATA variable is checked&quot;) + theme(axis.title = element_blank(), legend.position = &quot;none&quot;) 3.3 Fine-tuning biplots with different types of variables p2_ca_cider_cata has a lot of different aesthetics, some of . Using the existing column names and variable-codes in our original data to make a first draft of a plot, it would’ve looked more like this: draft_cider_plot &lt;- ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point() + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_bw() + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) draft_cider_plot 3.3.1 Axis and plot labels based on variables The FactoMineR plot we briefly showed in Chapter 1 included the percentage of inertia explained by each dimension in the axis labels, which is extremely nice, even though it’s difficult to adjust the FactoMineR plot directly. The FactoMineR::CA() function gives us all of the information we need to add this to our ggplot, and in our data set it’s saved in the ca_cider$eig matrix. ca_cider$eig #the second column has the percentage of variance explained by each dimension ## eigenvalue percentage of variance cumulative percentage of variance ## dim 1 0.055398432 60.446394 60.44639 ## dim 2 0.017914259 19.546625 79.99302 ## dim 3 0.009328142 10.178132 90.17115 ## dim 4 0.005637110 6.150769 96.32192 ## dim 5 0.003370919 3.678080 100.00000 if you give str_c() multiple vectors with the same length, it’ll combine the first element of the first vector with the first element of the second vector, and so on. So we could easily make a list of plot labels for each axis we have: str_c(rownames(ca_cider$eig), &quot; (&quot;, # you&#39;ll need to add the symbols yourself, including spaces round(ca_cider$eig[, 2], 1), &quot;%)&quot;) ## [1] &quot;dim 1 (60.4%)&quot; &quot;dim 2 (19.5%)&quot; &quot;dim 3 (10.2%)&quot; &quot;dim 4 (6.2%)&quot; ## [5] &quot;dim 5 (3.7%)&quot; # Or you can do it one at a time: str_c(&quot;Dimension 1 (&quot;, round(ca_cider$eig[1, 2], 1), &quot;% of intertia)&quot;) ## [1] &quot;Dimension 1 (60.4% of intertia)&quot; str_c(&quot;Dimension 2 (&quot;, round(ca_cider$eig[2, 2], 1), &quot;% of intertia)&quot;) ## [1] &quot;Dimension 2 (19.5% of intertia)&quot; To add it to the plot, we can use the labs() function, which lets you label the x and y axes, the whole plot title, and so on. draft_cider_plot + labs(x = str_c(&quot;Dimension 1, &quot;, round(ca_cider$eig[1, 2], 1), &quot;% of inertia&quot;), y = str_c(&quot;Dimension 2, &quot;, round(ca_cider$eig[2, 2], 1), &quot;% of inertia&quot;), subtitle = &quot;Correspondence Analysis biplot (symmetric)&quot;, #if you want to insert a line break, you can use `\\n`: title = &quot;Effect of cider serving temperature on consumer sensory perception\\nbased on CATA data&quot;) 3.3.2 Setting up the Cartesian plane You may have noticed that ggplot2 doesn’t give any particular weight to the origin, or the gridlines that pass through it, even though (0,0) is often meaningful and we may want to see which points are positive or negative at a glance. Removing all gridlines or using theme_void() removes the x- and y-axes as well! The easiest way to address this is just to add two lines that are thicker/darker/different at \\(y = 0\\) and \\(x = 0\\), which we can do by adding more geom_*()s… draft_cider_plot + theme_void() + geom_vline(xintercept = 0, color = &quot;grey&quot;, linewidth = 1) + geom_hline(yintercept = 0, color = &quot;grey&quot;, linewidth = 1) But if you aren’t careful and add them after your other geoms, it will add them on top of the rest of the plot. In general, you should go ahead and add your axis lines right after calling ggplot(), before anything else, so that they’re drawn on first and every other geom_*() goes on top of it. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_vline(xintercept = 0) + geom_hline(yintercept = 0) + geom_point() + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_void() You can also make your plot more intuitive to read by ensuring that 1 unit of the x-axis is the same distance as one unit on the y-axis, using coord_equal(). ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_vline(xintercept = 0) + geom_hline(yintercept = 0) + geom_point() + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_bw() + coord_equal() This will often make plots resulting from SVD wider than they are tall, since the 1st dimension will definitionally explain more variation in the data. 3.3.3 Using only part of the dataset for each geom Many methods of SVD, including Correspondence Analysis, combine points from different datasets or yield coordinates for row and column variables that you may want to display significantly differently–maybe you want your PCA columns to be arrows instead of points, or (as you’ve seen above) having a point and a text label for every attribute is too busy. How do we plot only a subset of points for certain geom_*()s? You already know how to make certain subsets of points a different shape, color, size, opacity, and so on. But how do you avoid plotting certain subsets at all? You have to make a data frame with only the rows that you want e.g., geom_point(), to plot, and pass it into the data argument. We’ll show how to do this using the tidyverse function filter(), but if there’s another way you’re more comfortable with then use that instead. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point(data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;)) + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_bw() If the columns happened to have different names, you’d have to specify the aes() mappings separately in each geom_*(), and it may make more sense to start with an empty ggplot() call and then add on geom_*()s each with their own mapping and data arguments if there’s just one geom_*() per data frame. 3.3.4 Tweaking legends Legends can often get busy, or have information on them that’s not actually clarifying anything in the plot, especially when you’ve got geom_*()s on the same plot using different datasets so that, for example, the color of the points isn’t adding anything. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point(aes(shape = Temperature), data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;)) + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_bw() If you want to remove specific geoms from the legend, then you have to adjust your geom_*() calls. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point(aes(shape = Temperature), data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;), show.legend = FALSE) + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_bw() If you want to move specific aesthetics (linetype, linewidth, color, shape, etc) from the legend, then you can add the guides() function to your plot and specify which ones should be in the legend and which shouldn’t. ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point(aes(shape = Temperature), data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;)) + ggrepel::geom_text_repel(mapping = aes(label = name)) + theme_bw() + guides(shape = guide_legend(), color = &quot;none&quot;) 3.3.5 Aesthetics that can’t use scale_*() functions It’s also common for row and column biplots to use different text styling for the row and column variables. Based on what you know so far, since we have the row/column designation in the type column, you might start out trying to set the fontface aesthetic like this: ca_cider_coords %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point() + ggrepel::geom_text_repel(mapping = aes(label = name, fontface = type)) + theme_bw() + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) ## Error in FUN(X[[i]], ...): invalid fontface row You can map variable levels to colors, shapes, sizes, and so on using the scale_*() functions, but not all aesthetics can be controlled in this way. Most of the exceptions are related to text–font face, font family, and the justification of the text require that you have a variable that contains the name or value directly (plain, bold, italic, or bold.italic for fontface; serif, sans-serif, or monospace for family; and a number from 0-1 for hjust and vjust), if one geom_text() should have different values for different rows. Basically, if we want to accomplish this in ggplot2, we’ll need to make a column with plain for our rows with samples and italic for our rows with CATA variables. ca_cider_coords %&gt;% mutate(font = if_else(type == &quot;row&quot;, &quot;plain&quot;, &quot;italic&quot;)) %&gt;% ggplot(mapping = aes(x = `Dim 1`, y = `Dim 2`, color = type)) + geom_point() + ggrepel::geom_text_repel(mapping = aes(label = name, fontface = font)) + theme_bw() + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) 3.3.6 Putting it all together Finally, as our last act, we’re ready to walk line-by-line through the last example figure, our fancier correspondence analysis plot. nice_cider_labels &lt;- labs(x = str_c(&quot;Dimension 1, &quot;, round(ca_cider$eig[1, 2], 1), &quot;% of inertia&quot;), y = str_c(&quot;Dimension 2, &quot;, round(ca_cider$eig[2, 2], 1), &quot;% of inertia&quot;), subtitle = &quot;Correspondence Analysis biplot (symmetric)&quot;, title = &quot;Effect of cider serving temperature on consumer sensory perception&quot;) ca_cider_termplot &lt;- ca_cider_coords %&gt;% mutate(font = if_else(type == &quot;row&quot;, &quot;plain&quot;, &quot;italic&quot;)) %&gt;% ggplot(aes(x = `Dim 1`, y = `Dim 2`)) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, color = &quot;darkgrey&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;darkgrey&quot;) + geom_point(aes(color = type, shape = Temperature), data = ca_cider_coords %&gt;% filter(type == &quot;row&quot;), size = 3) + ggrepel::geom_text_repel(aes(label = name, color = type, fontface = font), show.legend = FALSE) + coord_equal() + theme_bw() + theme(legend.position = &quot;bottom&quot;) + nice_cider_labels + scale_color_manual(values = c(&quot;darkorange&quot;, &quot;darkgreen&quot;)) + scale_shape_manual(values = c(8, 16)) + guides(shape = guide_legend(), color = &quot;none&quot;) ca_cider_termplot save(ca_cider_termplot, file = &quot;data/ca_cider_termplot.RData&quot;) "],["wrap-up-and-further-resources.html", "4 Wrap-up and further resources 4.1 Getting help 4.2 Further reading/resources 4.3 Questions/Comments 4.4 References", " 4 Wrap-up and further resources Let’s look back at what we were aiming to do today: In this tutorial, we will introduce the audience to ggplot2 and the rest of the tidyverse R packages with the aim of developing sufficient basic skills to visualize multivariate sensory and consumer data. We will provide a learning dataset for the analysis—a set of free response comments and overall liking scores from a central location test on berries. We will teach participants how to import, manipulate, and plot data using user-friendly, “tidy” R programming. All resources used in the tutorial are open-source and will remain available to attendees, including an R script covering the full workflow. At the end of the tutorial, attendees will be able to prepare raw sensory data for common multivariate visual representations in R. We have managed to touch on all of these topics, but of course we have taken the most cursory look at each. I hope what we’ve gone over today has inspired you, sure, but I mostly hope it has shown you how much you can do with just a little knowledge. My journey in terms of learning data science with R has been all about building my coding ability incrementally. My code looks more like this than anything else, but I am able to get so much done: What does good code even look like? (via XKCD) By developing your ability to code (in R or Python, or whatever works for you–Julia?) you will open up a whole set of analyses that you would otherwise be unable to access. 4.1 Getting help Look up the help file for whatever you’re doing. Do this by using the syntax ?&lt;search item&gt; (for example ?c gets help on the vector command) as a shortcut on the console. Search the help files for a term you think is related. Can’t remember the command for making a sequence of integers? Go to the “Help” pane in RStudio and search in the search box for “sequence”. See if some of the top results get you what you need. The internet. Seriously. I am not kidding even a little bit. R has one of the most active and (surprisingly) helpful user communities I’ve ever encountered. Try going to google and searching for “How do I make a sequence of numbers in R?” You will find quite a bit of useful help. I find the following sites particularly helpful Stack Overflow Cross Validated/Stack Exchange Seriously, Google will get you most of the way to helpful answers for many basic R questions. I want to emphasize that looking up help is normal. I do it all the time. Learning to ask questions in helpful ways, how to quickly parse the information you find, and how to slightly alter the answers to suit your particular situation are key skills. 4.2 Further reading/resources General R programming Data Carpentry’s R for Social Scientists (and, really the courses from The Carpentries in general) Wickham &amp; Grolemund’s R for Data Science The stat545 course website My own (somewhat opinionated and eccentric) course from VT: FST 5984 Data Visualization Best Practices Healy’s Data Visualization “Caveats” from the website Data to Viz, including topics such as why radar plots &amp; pie charts are controversial and what to use instead. ggplot2-specific Winston Chang’s R Graphics Cookbook, basically a collection of short tips and sample plots R Graph Gallery’s posts breaking down the code to make real, complex, polished ggplots ggplot2’s registered extension gallery We will also be presenting… 4.3 Questions/Comments If you get stuck, feel free to find us during the conference, or email us at jlahne at vt dot edu and lhamilton at vsu dot edu. I’d love to learn about what you’re working on! 4.4 References Calvert, Martha D., Elizabeth Cole, Amanda C. Stewart, Clinton L. Neill, and Jacob Lahne. 2022. “Can Cider Chemistry Predict Sensory Dryness? Benchmarking the Merlyn Dryness Scale.” Journal of the American Society of Brewing Chemists, October, 1–6. https://doi.org/10.1080/03610470.2022.2121562. Yeung, Henry F., Kumpol Homwongpanich, Elizabeth Michniuk, Dominic Rovai, Massimo Migliore, Amy Lammert, and Jacob Lahne. 2021. “A Tale of 3 Scales: How Do the 9-Pt, Labeled Affective Magnitude, and Unstructured Visual Analog Scales Differentiate Real Product Sets of Fresh Berries?” Food Quality and Preference 88 (March): 104109. https://doi.org/10.1016/j.foodqual.2020.104109. "],["appendix.html", "Appendix Using ggplot2 with other packages Combining Plots Image File Types, Sizes, and Resolutions Regular Expressions", " Appendix Using ggplot2 with other packages As you might have noticed, we had you download more packages than just ggplot2 for this tutorial. ggplot2 is a framework and will help you make many standard plots, but it can’t do everything. Or, sometimes, you may not want to use it to do everything yourself. Packages meant to work with ggplot2 to more easily make specific kinds of visualizations are also called ggplot extensions. The four most common kinds of ggplot extensions are: Packages that add geom_*()s or stat_*()s for new kinds of plots Packages that add theme_*()s and scale_*()s for specific color or style needs Packages that make ggplot objects, so you never write ggplot() yourself Packages that combine multiple plots in various ways You can view many of these extensions on the tidyverse website (where you’ll also see many examples that fall into multiple of these categories or don’t fit into the categories here at all). New theme_*()s and scale_*()s Most of the additional geom_*()s in ggplot2 extensions involve some sort of calculation, so the confidence that you’re using someone else’s algorithm that’s (hopefully!) been double-checked is a real benefit. You’ve already seen how to change the way your plots look with theme() one argument at a time, and how to set scale_*_manual() if you have the exact colors or color range that you want. So there’s nothing these prettying-up packages will do that you can’t do yourself, but there are a huge number of ggplot2 extensions that include some version of a no-gridline minimal theme for convenience. Such as: berry_long_liking %&gt;% ggplot(aes(x = Scale, y = Liking, color = Scale)) + ggbeeswarm::geom_quasirandom() + facet_wrap(~ Attribute) + cowplot::theme_minimal_hgrid() Packages that added scale_*()s used to be one of the most common kinds of ggplot extensions (because, as you’ll notice, the above figure with the default color scale is not red-green colorblind friendly), but the most popular scales now come with ggplot2 itself. RColorBrewer’s colorblind- and printer-friendly palettes for categorical data are now available in ggplot2::scale_*_brewer_*(), and you’ve already seen us use the viridis color palettes in ggplot2::scale_*_viridis_*(). The viridis color scales can be used for categorical data, if you use the _d() versions, but they were designed for ordinal and binned data, since some colors will seem more related than others. See Chapter 4 and Chapter 19 of Claus O. Wilke’s book Fundamentals of Data Visualization. Finding New Packages This isn’t all the functionality of any of these packages, and these aren’t the only packages that add new features to ggplot2. If you’re trying to figure out how to create a type of plot you’ve never made before, we’d recommend: Ask yourself what variables are represented by the x and y axes, the shapes, the line types, or the colors. Think about whether you can build the plot from smaller components. Is it a grid of scatterplots with colored contour regions? How much of the plot is just points, lines, or rectangles with fancy formatting? You can do a lot with just ggplot2! See if any of the packages in the list of registered ggplot extensions have a plot similar to yours. These packages tend to have very thorough and visual documentation. If it’s a sensory-specific plot, check out the R Opus v2. Almost all of the plots only use ggplot2, patchwork, and ggrepel. Use a web search with the kind of plot you want to make and the keyword “ggplot2” to find tutorials or discussions with example code. Results from Stack Overflow, Data to Viz, or R Graph Gallery are all likely to have good explanations and useful examples, while anything with “(# examples)” in the article name is likely to be very basic material with good SEO. Keep in mind that keywords primarily used in sensory science, say “preference map” or “penalty analysis”, are unlikely to yield examples in ggplot2 with extensive results. In my own process of troubleshooting and double-checking for this workshop, I’ve found some helpful examples by searching “add density contours to 2d scatterplot ggplot” or “ordered bar plot positive and negative ggplot”. Package documentation might come up while you’re looking, but the examples are often very abstract and simple, and they’re often structured around names of functions rather than concepts, so it’s often faster to see some examples of real plots that other people (who aren’t writing an entire R package) wanted to make and then looking up the functions they used to do so. Modifying ggplot()s made by other packages In the workshop, we made almost all of our plots by calling ggplot() and then adding on geoms, themes, labels, scales, and facets with +, and we briefly alluded to why this is in Chapter 1. But some packages do utilize ggplot2 by making a whole plot for you with their own internal call to ggplot(), including FactoMineR, and you’ve seen us keep adding things to plots we’ve saved in variables. If you find yourself just slightly wanting to tweak the plot a package is saving to a variable (or a list, for several plots), it may be possible to do so with + semantics, instead of recreating the whole plot yourself. That’s what this section of the appendix will walk through. #FactoMineR uses ggplot for its internal plotting, #Which is why we can assign the output to a variable #and not see the plot right away #(although the CA() function will also display several plots by default) cider_contingency %&gt;% FactoMineR::CA(graph = FALSE) %&gt;% FactoMineR::plot.CA() -&gt; ca_cider_biplot_facto #The ca package, meanwhile, uses base plotting. #You can tell because it prints this plot immediately. cider_contingency %&gt;% ca::ca() %&gt;% ca::plot.ca() -&gt; ca_cider_biplot_green You can see that the last code chunk only output one plot right away, but we can confirm our suspicions with the base R class() function. class(ca_cider_termplot) # Made with ggplot() ourselves ## [1] &quot;gg&quot; &quot;ggplot&quot; class(ca_cider_biplot_facto) # Made with ggplot-based FactoMineR ## [1] &quot;gg&quot; &quot;ggplot&quot; class(ca_cider_biplot_green) # Made with ca::ca(), not a plot at all ## [1] &quot;list&quot; ca_cider_biplot_green # It&#39;s two tables of coordinates! ## $rows ## Dim1 Dim2 ## 1911 Est. Chilled -0.30922746 0.02323046 ## 1911 Est. RT -0.33096663 0.04492088 ## Buskey Chilled 0.01508206 -0.16463573 ## Buskey RT 0.19222871 -0.19341072 ## Eden Chilled 0.22460300 0.13702229 ## Eden RT 0.20122093 0.14661009 ## ## $cols ## Dim1 Dim2 ## Fresh_Apples -0.30305451 0.08260444 ## Fermented 0.05136995 -0.11123214 ## Herbal 0.27953814 0.05798442 ## Dry 0.09068713 -0.09458987 ## Spice 0.09194648 -0.15607561 ## Fruity -0.26360780 0.04401256 ## Smooth -0.23141023 -0.16865980 ## Alcohol 0.08456228 -0.05135981 ## Light -0.13444990 -0.13768159 ## Sweet -0.13152453 -0.06963735 ## Woody 0.32164765 0.18574435 ## Berries -0.38694032 0.08324652 ## Sour -0.03153644 0.19917586 ## Funky 0.56153039 -0.01014260 ## FullBodied -0.01727177 -0.10673686 ## Metallic 0.13770506 0.36391448 ## Floral 0.05665116 -0.01517803 ## Candy -0.73752932 0.35245085 ## Bitter 0.17535866 -0.02812715 ## Vomit 0.43823154 0.03719609 ## Earthy 0.43043925 -0.06405187 ## Synthetic 0.35094003 0.33924051 What this means is that we can look at the FactoMineR-made plot we’ve saved to ca_cider_biplot_facto: ca_cider_biplot_facto And we can still change up many of the elements by adding additional elements, although you’re likely to get some weird warning messages and some silent errors. (The ggrepel error message is actually just because there are too many geom_text_repel() labels close-together in a small plots, because expanding xlim() crowds everything in the center of the plot.) ca_cider_biplot_facto + theme(panel.grid = element_blank(), # Removes the axis lines plot.title = element_blank()) + # Removes the title xlim(-1,1) + # Extends the x limits, with a warning scale_color_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) # Silently fails to change the color scale You can’t just + scale_color_*() to a FactoMineR plot, because the ggplot already has a non-default color scheme and adding a second color scale does nothing. If you look at the help file for ?FactoMineR::plot.CA, you can set several styling parameters when you’re making the plot, and you can remake it as many times as you need, but doing so does have significantly less flexibility than the approach to plotting we’ve outlined in this workshop. We also can’t go back and adjust the parameters passed to geom_text_repel() after the fact, even though we can tell from the warning messages that that’s the package being used to put the attribute and product names onto the biplot. It will almost always be possible to add more geom_*()s to plots made by other packages, as long as you don’t mind them being added on top of any existing elements in the plot. liking_arrow &lt;- data.frame(x1 = 0, y1 = 0, x2 = -0.4, y2 = -0.1, text = &quot;Liking&quot;) ca_cider_biplot_facto + geom_segment(aes(x= x1, y = y1, xend = x2, yend = y2), color = &quot;orange&quot;, arrow = arrow(length = unit(0.03, &quot;npc&quot;)), linewidth = 1, data = liking_arrow) + geom_text(aes(x = x2, y = y2, label = text), color = &quot;orange&quot;, hjust = &quot;outward&quot;, vjust = &quot;outward&quot;, fontface = &quot;italic&quot;, data = liking_arrow) If you desperately need to change a scale or reorder geom_*()s from an existing ggplot in a hurry, look into the gginnards package. Combining Plots During the workshop, we showed how to use facet_*() to view “small multiple” plots side-by side: raw_cider_data &lt;- read_csv(&quot;data/CiderDryness_SensoryDATA.csv&quot;) raw_cider_data %&gt;% pivot_longer(Fresh_Apples:Synthetic) %&gt;% group_by(Sample_Name, Temperature, name) %&gt;% summarize(total = sum(value)) %&gt;% ggplot(aes(x = interaction(Sample_Name, Temperature), y = total)) + geom_col(aes(fill = Sample_Name)) + scale_fill_manual(values = wesanderson::wes_palettes$FantasticFox1) + coord_flip() + labs(x = NULL, y = NULL, fill = NULL) + theme_bw() + theme(legend.position = &quot;top&quot;, panel.grid = element_blank()) -&gt; cider_count_plot cider_count_plot + facet_wrap(~name, ncol = 6) This works very well whenever you have multiple plots using the same geom_*()s that you want to show on the same axes, and you can even adjust the axis limits from facet to facet using scales = \"free*\": cider_count_plot + facet_wrap(~name, ncol = 6, scales = &quot;free_x&quot;) # Each plot now has a different x-axis Not that we’d argue you should here. Also, take note that the x in free_x refers to the horizontal axis in the final plot, after the coord_flip(), and not the x aesthetic we set in the ggplot() call. But if you have different plot types entirely (different data sources, different geom_()s, or different categorical axes) that you want to place side-by-side, say a loading plot and the product map resulting from a PCA or MFA, you’re going to need something to paste together multiple ggplot_()s. The easiest way to do this is using patchwork, which will work on ggplots you’ve made yourself or with ones made by packages like FactoMineR. When you have patchwork loaded, the + operator will put two plots side-by-side: library(patchwork) berry_mfa_summary %&gt;% FactoMineR::MFA(group = c(sum(str_detect(colnames(berry_mfa_summary), &quot;^cata_&quot;)), sum(str_detect(colnames(berry_mfa_summary), &quot;^liking_&quot;))), type = c(&quot;f&quot;,&quot;s&quot;), graph = FALSE, name.group = c(&quot;CATA&quot;,&quot;Liking&quot;)) -&gt; berry_mfa_res plot(berry_mfa_res, choix = &quot;var&quot;) + plot(berry_mfa_res, partial = &quot;all&quot;) And the / operator will arrange two plots vertically: plot(berry_mfa_res, choix = &quot;var&quot;) / plot(berry_mfa_res, partial = &quot;all&quot;) The advantage of doing this with a package like patchwork, rather than saving separate images, is that it aligns all of the plot areas precisely and that they will more easily move or rearrange certain plot elements like legends and axis labels. plot(berry_mfa_res, choix = &quot;var&quot;) + plot(berry_mfa_res, partial = &quot;all&quot;) + plot_layout(guides = &quot;collect&quot;) &amp; theme(plot.title = element_blank(), legend.position = &quot;bottom&quot;) The &amp; operator lets you add elements like themes or annotations to all of the plots you’ve combined together. plot_layout() is a patchwork function that lets you set relative plot sizes, decide how to arrange more than 2 plots, and move legends: plot(berry_mfa_res, partial = &quot;all&quot;) + (plot(berry_mfa_res, choix = &quot;var&quot;) + plot(berry_mfa_res, choix = &quot;freq&quot;, invisible = &quot;ind&quot;)) + plot_layout(guides = &quot;collect&quot;, ncol = 1, widths = 2) &amp; theme(plot.title = element_blank(), axis.title = element_blank(), legend.position = &quot;bottom&quot;) If you want to put images anywhere on a visualization, you’re struggling to make a complex arrangement with patchwork, or you have an R list structure containing multiple plots (say, the result of a for loop, *apply(), or nest() call), then cowplot is another option: berry_mfa_res$separate.analyses %&gt;% lapply(function(x) { x$ind$coord %&gt;% as_tibble(rownames = &quot;Berry&quot;) %&gt;% ggplot(aes(x = Dim.1, y = Dim.2)) + geom_point() }) %&gt;% cowplot::plot_grid(plotlist = ., labels = names(.)) #You can also pipe your list into patchwork::wrap_plots() #if you have the latest version of patchwork. #It&#39;s a fairly new package, so it gains big new features very often. Both of these packages can also add letters and other labels to each plot: plot(berry_mfa_res, choix = &quot;var&quot;) + plot(berry_mfa_res, partial = &quot;all&quot;) + plot_layout(guides = &quot;collect&quot;) + plot_annotation(tag_levels = &#39;A&#39;) &amp; theme(plot.title = element_blank(), legend.position = &quot;bottom&quot;) cowplot::plot_grid(plot(berry_mfa_res, choix = &quot;var&quot;), plot(berry_mfa_res, partial = &quot;all&quot;), labels = &quot;AUTO&quot;) #Cowplot doesn&#39;t have a way to combine or move legends. #You&#39;d have to move the legends *before* using plot_grid() If you need to move or realign the labels so they’re not overlapping anything, in patchwork you can add theme(plot.tag.position = c(X, Y)) to individual plots with + or to the whole grouping of plots with &amp;. The cowplot::plot_grid() function has arguments labels_x and labels_y, which let you adjust the distance from the bottom left hand corner of the figure. plot(berry_mfa_res, choix = &quot;var&quot;) + theme(plot.tag.position = c(0.2, 0.95)) + plot(berry_mfa_res, partial = &quot;all&quot;) + theme(plot.tag.position = c(0.12, 0.95)) + plot_layout(guides = &quot;collect&quot;) + plot_annotation(tag_levels = &#39;A&#39;) &amp; theme(plot.title = element_blank(), legend.position = &quot;bottom&quot;) cowplot::plot_grid(plot(berry_mfa_res, choix = &quot;var&quot;), plot(berry_mfa_res, partial = &quot;all&quot;), labels = &quot;AUTO&quot;, label_y = 0.8) You can also use any image editing, publishing, or graphics software to manually combine, arrange, and label plots, but if you need to make changes to a plot later then doing your layout in R will mean you just have to run the lightly-updated code again to re-export a fully formatted multi-part figure, even if the plot dimensions change. Image File Types, Sizes, and Resolutions What image format? There are two major ways to save the kind of spatial color data that comprise images such as graphs. You can store them as vector graphics, which can be rescaled because they’re made up of lines and shapes (most commonly, .pdf and .svg) or as raster (bitmap) graphics, which store images as a grid of pixels which each have a single uniform color (most commonly, .png and .jpeg). .pdf vector images are best for LaTeX and professional publishing .svg vector images are more widely supported in word processors and websites .png raster images are the most predictable to print, the best for web publishing, and can be used in pretty much every software ever made, if you know exactly the size you want. .jpeg (along with .tiff) raster images are the raster format preferred by Food Quality and Preference editors. They are worse for web publishing than .png but share its other advantages and usually take up less storage space. ggsave() supports all of the above-named image formats, as well as .eps, .ps, .tex (pictex), and .bmp. It will figure out from the file extension (the stuff after the . in the filename argument) what image type it’s saving as, but you can also specify it explicitly with the device argument. If you’re reading this right now, you’re looking at a webpage created using bookdown and knitr. We can’t actually directly embed .pdf images in this site, but let’s look at a few other example formats using the same plots. ggsave(&quot;img/penalty-lift-svg.svg&quot;, p1_berry_penalty) ggsave(&quot;img/penalty-lift-jpeg.jpeg&quot;, p1_berry_penalty) ggsave(&#39;img/penalty-lift-png.png&#39;, p1_berry_penalty) Now let’s compare how each of these looks! First, inside R: p1_berry_penalty # If you&#39;re following along, this will look different in your R session! The .svg image made by ggsave(): The .png image made by ggsave(): The .jpeg image made by ggsave(): The two raster formats look basically the same, and only slightly different from the .svg and the version in the .html version of this tutorial. If you’re following along in your own R session, however, you’ll notice that these saved plots all look more similar to each other than they do to the initial plot you’re previewing inside R. All of the plots have a bit more space around the text using ggsave(), taller bars, and a different aspect ratio (\\(width/height\\)). We can adjust these using the rest of the arguments to ggsave(). The width, height, and units primarily control the image size (for raster images) and aspect ratio (for all images), but they also affect the relative size of plot elements. Larger plots will have axis labels, text, and geom_*()s that take up less of the overall plotting area, and vice-versa for smaller images. If you get to this stage with a vector image and realize that all of the fixed-size elements (e.g., text) are too big or too small, you can use ggsave()’s scale argument. scale &lt; 1 makes all the fixed-size elements smaller relative to the plot size and scale &gt; 1 makes all the elements bigger relative to the plot size. scale &lt; 1 will generally also give you a larger plot area and more space between your geoms. ggsave(&quot;img/penalty-lift-svg-7x4.svg&quot;, p1_berry_penalty, width = 7, height = 4, units = &quot;in&quot;) ggsave(&quot;img/penalty-lift-svg-14x8.svg&quot;, p1_berry_penalty, width = 14, height = 8, units = &quot;in&quot;) ggsave(&quot;img/penalty-lift-svg-14x8-rescale.svg&quot;, p1_berry_penalty, width = 14, height = 8, units = &quot;in&quot;, scale = .5) The 7x4” vector plot: The same plot saved at 14x8”: A 14.8” plot with scale = 0.5: All of these .svg images are displayed at 7x4” on your screen, but the plot we made with width = 14, height = 8 has smaller text and larger plotting areas unless we correct this with scale. penalty-lift-svg-7x4.svg and penalty-lift-svg-14x8-rescale.svg are actually identical files. You should avoid using scale for rasters, as it will create plots that will not print at the size (width and height) and resolution (dpi) you specified. If you find yourself wanting to change the scale of a raster image, you should refer to the reference we’ve put together on dpi in the Appendix. Simpler Sizing: Vector Images You might be surprised that vector images have height and width options, because we said they don’t have a fixed display size, but as you saw in Chapter 3, ggsave() picked a default image size of 7x7 inches when we didn’t specify. The height and width are mostly important for determining the relative sizing of elements like text and whitespace. ggplot2 actually saves the sizes of certain plot elements, namely text and most geom_*()s, in inches or millimeters. When it has to construct an actual version of the plot at a given size, it tries to keep all of the 12-pt text 1/6” tall (1 inch = 72 points). This 12-point font will take up a very small amount of a 4-foot-tall image, but a sixth of a 1” image. The fact that you can then print the .svg at any size you want is out of ggplot2’s hands. It will try to make the fonts and elements the right size for the size you’re telling it you will print. This means that the scale argument of ggsave(), for vectors, can just change the output size as long as you keep the same aspect ratio. It doesn’t change the number of points per inch, and it doesn’t change the point-size of any fonts or other elements in the plot. It’s easier to just print a different size figure. If you try to use this same trick for raster images, your picture will not be \\(width \\times dpi\\) pixels wide. This has flummoxed many a researcher trying to export very large, crisp figures for a poster. Raster Image Resolutions All raster images are made up of grids of dots or pixels. Once you export a figure from R as a .png, .jpeg, or other raster format, you cannot resize it. It will look blurry or blocky if you try to make it bigger, and even slight changes to the aspect ratio (\\(width/height\\)), the text and other plot elements will be noticeably stretched out. You’ll have fewer problems if you save an image that’s way too big (i.e., has too many pixels) for what you need, so long as it’s the right aspect ratio and all the plot elements have relative sizes that work at the scale you’ll be printing. (See this short primer on “Using R Plots in Documents” from the University of Wisconsin-Madison for examples.) So, how big is a pixel? How many pixels are in an inch? It depends! (On the pixel density for screens and the resolution for printing, see the discussion on this page for details.) Most modern computer monitors have something like 90-120 pixels per inch (ppi) Microsoft Powerpoint uses an internal resolution of 96 ppi as a default, although images will print at more than 96 dpi if they’re sized appropriately. Older Apple software has a default of 72 ppi ggsave() uses a default of 300 dpi Poster printers will usually print at 300 dots per inch (dpi). They may ask for a minimum resolution of anywhere between 120-300 dpi, although 300 dpi will usually be a safe bet. Use your specific printer’s recommendations. Elsevier journals like Food Quality and Preference suggest at least 300 dpi for all images and at least 500 dpi for “combination art”, which includes all R plots with colored or shaded areas. This is important because, if you have a 600x600-pixel raster image, and you try to print it any bigger than 2 inches x 2 inches on a 300 dpi printer, then you have missing image data and the printed version will look blurry. Whenever something, like a design software or an R function to save a plot, gives you the chance to enter an image size in inches or centimeters, you should figure out what dpi or ppi it’s using. It may be easier to figure out the final pixel size you want and export something that size or bigger. (For more details, see this guide on “Preparing Images for PowerPoint, the Web, and Publication” from the University of Michigan. It’s slightly outdated, so ignore the specific dpi/ppi numbers.) You can see the possible image widths and corresponding pixel sizes for Elsevier journals here. For PowerPoint presentations, assume you’re filling a 13.3x7.5” space at 150 dpi. For printed posters, you’ll find the final poster size on the competition guidelines and the final resolution from your printer. 12”x12” for a single figure at 300 dpi is a good place to start. You will almost certainly have to re-export your figures several times in order to get the sizing and aspect ratios right. Let’s save a the same plots as a raster image (.png) with a few different dpi values. ggsave(&quot;img/penalty-lift-png-50dpi.png&quot;, p1_berry_penalty, width = 7, height = 4, units = &quot;in&quot;, dpi = 50) ggsave(&quot;img/penalty-lift-png-300dpi.png&quot;, p1_berry_penalty, width = 7, height = 4, units = &quot;in&quot;) #default dpi = 300 ggsave(&quot;img/penalty-lift-png-500dpi.png&quot;, p1_berry_penalty, width = 7, height = 4, units = &quot;in&quot;, dpi = 500) 7x4” at 50 dpi: 7x4” at 300 dpi (the ggsave() default): 7x4” at 500 dpi: You can see that all of the 7x4” raster plots look basically the same, except the first one is a little blurry when it’s sized up to match the other two on your probably ~100 dpi monitor. This is the problem we’re trying to avoid. Unlike scale, the dpi argument does not resize any of the text or geoms (it doesn’t change the size of a “point” from 1/72”). But let’s say we need a 300 dpi copy of this image printed at 14x8”. We already know that the 14x8” output has text that’s too small to read from afar. In cases like these, it may be easier to output a size with the right aspect ratio that looks good and is legible, then figure out what dpi you’ll need to print it. If we need a 14x8” plot at 300 dpi, that’s \\(14 \\times 300 = 4200\\) pixels wide by \\(8 \\times 300 = 2400\\) tall. We can fake this with our 7x4” plot at 600 dpi, since \\(4200 / 7 = 600\\) and \\(2400 / 4 = 600\\). 4.4.1 Other Image Export Options This is not a knitr or bookdown tutorial, but we used the bookdown package to make the online webpage version of this tutorial. It comes with its own advantages and challenges, but it does significantly streamline the image-generation process for any project where the only file you need is one LaTeX file, .html page, or .pdf output with all of the text and all of the figures. If that sounds appealing to you, turn your attention to “bookdown: Authoring Books and Technical Documents with R Markdown” by Yihui Xie. Regular Expressions A regular expression, or regex, is a way of compactly writing a pattern that will let you match similarly-structured pieces of text. You may use regex because you want the list of matches itself, because you want to do something to pieces of text with a certain pattern somewhere in them, or because you want to replace all matches with something else. Regex were originally designed in the 1980s, and are also a central part of the design of the stringr package (although stringr still has a lot of useful tools without them). If you wanted to match all words ending in “ly”, you could use \\\\b\\\\w+ly\\\\b, which looks for a word boundary (\\\\b), followed by at least one (+) “word character” (\\\\w, mostly letters), followed by the letters “ly”, followed by another word boundary. You can use a similar regex to find all integers (\\\\b\\\\d+\\\\b) or expand it to find integers and numbers with a decimal (\\\\b\\\\d+(\\\\.\\\\d+)?\\\\b). Mostly, Regex are very powerful and very difficult to read. We’ll provide a few semi-realistic examples in action to show off just how powerful they can be, and just how messy they look: str_extract(&quot;If you want to get in touch with me you can do so at hamilton@flavorlinguist.com.&quot;, &quot;\\\\w*@\\\\w+\\\\.(edu|gov|com|org|biz|net|fr|co\\\\.uk)\\\\b&quot;) ## [1] &quot;hamilton@flavorlinguist.com&quot; str_extract_all(&quot;Our 300th measurement was 10.31 cm, our 301st clocked in at 3.213in&quot;, &quot;\\\\d+\\\\.\\\\d+ ?(cm|in|m)&quot;) ## [[1]] ## [1] &quot;10.31 cm&quot; &quot;3.213in&quot; str_extract_all(&quot;Regular Expressions (regex) are one tool in Natural Language Processing (NLP)&quot;, &quot;(?&lt;=\\\\()[^)]*(?=\\\\))&quot;) ## [[1]] ## [1] &quot;regex&quot; &quot;NLP&quot; You can try changing the searched string in the above code to see if it recognizes your email or how many numbers you can get it to recognize. Usually, though, your plot labels aren’t in full sentences in your data frame. Simpler regular expressions can still save you a lot of work. Without regular expressions, our main penalty analysis example has to separate() the CATA variable names into two parts, use a case_when() to individually match the modalities to a cleaned-up “(A)” or “(T)”, and then finally unite() them back into one column: berry_penalty_analysis_data %&gt;% select(-count) %&gt;% pivot_wider(names_from = checked, values_from = penalty_lift, names_prefix = &quot;checked_&quot;) %&gt;% separate(cata_variable, into = c(&quot;mode&quot;, &quot;variable&quot;), sep = &quot;_&quot;) %&gt;% mutate(mode = case_when(mode == &quot;taste&quot; ~ &quot;(T)&quot;, mode == &quot;appearance&quot; ~ &quot;(A)&quot;, mode == &quot;appearane&quot; ~ &quot;(A)&quot;)) %&gt;% unite(variable, mode, col = &quot;cata_variable&quot;, sep = &quot; &quot;) ## # A tibble: 85 × 4 ## berry cata_variable checked_0 checked_1 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 blackberry fresh (A) 4.70 5.80 ## 2 blackberry goodcolor (A) 4.63 5.77 ## 3 blackberry goodquality (A) 4.69 5.96 ## 4 blackberry goodshapre (A) 4.93 5.86 ## 5 blackberry misshapen (A) 5.63 4.92 ## 6 blackberry none (A) 5.42 4.78 ## 7 blackberry notfresh (A) 5.57 3.76 ## 8 blackberry unevencolor (A) 5.53 4.53 ## 9 blackberry bruised (A) 5.53 4.67 ## 10 blackberry berry (T) 4.21 6.49 ## # ℹ 75 more rows With regular expressions, you can combine all of this in one step: berry_penalty_analysis_data %&gt;% select(-count) %&gt;% pivot_wider(names_from = checked, values_from = penalty_lift, names_prefix = &quot;checked_&quot;) %&gt;% mutate(cata_variable = str_replace(cata_variable, &quot;^(.).*_(.*)&quot;, &quot;\\\\2 (\\\\1)&quot;), cata_variable = str_to_title(cata_variable)) ## # A tibble: 85 × 4 ## berry cata_variable checked_0 checked_1 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 blackberry Fresh (A) 4.70 5.80 ## 2 blackberry Goodcolor (A) 4.63 5.77 ## 3 blackberry Goodquality (A) 4.69 5.96 ## 4 blackberry Goodshapre (A) 4.93 5.86 ## 5 blackberry Misshapen (A) 5.63 4.92 ## 6 blackberry None (A) 5.42 4.78 ## 7 blackberry Notfresh (A) 5.57 3.76 ## 8 blackberry Unevencolor (A) 5.53 4.53 ## 9 blackberry Bruised (A) 5.53 4.67 ## 10 blackberry Berry (T) 4.21 6.49 ## # ℹ 75 more rows And you can even go farther by combining multiple replacements (for typos, for adding in spaces, etc) in one call to str_replace_all(). berry_penalty_analysis_data %&gt;% select(-count) %&gt;% pivot_wider(names_from = checked, values_from = penalty_lift, names_prefix = &quot;checked_&quot;) %&gt;% mutate(cata_variable = str_replace_all(cata_variable, c(&quot;^(.).*_(.*)&quot; = &quot;\\\\2 (\\\\1)&quot;, &quot;good&quot; = &quot;good &quot;, &quot;not&quot; = &quot;not &quot;, &quot;shapre&quot; = &quot;shape&quot;, &quot;uneven&quot; = &quot;uneven &quot;)), cata_variable = str_to_title(cata_variable)) ## # A tibble: 85 × 4 ## berry cata_variable checked_0 checked_1 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 blackberry Fresh (A) 4.70 5.80 ## 2 blackberry Good Color (A) 4.63 5.77 ## 3 blackberry Good Quality (A) 4.69 5.96 ## 4 blackberry Good Shape (A) 4.93 5.86 ## 5 blackberry Misshapen (A) 5.63 4.92 ## 6 blackberry None (A) 5.42 4.78 ## 7 blackberry Not Fresh (A) 5.57 3.76 ## 8 blackberry Uneven Color (A) 5.53 4.53 ## 9 blackberry Bruised (A) 5.53 4.67 ## 10 blackberry Berry (T) 4.21 6.49 ## # ℹ 75 more rows You do not have to learn regular expressions to clean up messy text, but being comfortable with them will (eventually) make you faster. You should at least learn the characters (\\, ., [, ], {, }, (, ), &lt;, &gt;, *, +, -, =, !, ?, ^, $, and |) that will need to be escaped with two backslashes if you need to replace them. It will help you troubleshoot any weird results you get from the str_*() functions. If you want to learn more, we’d recommend starting with the stringr package’s own vignette on regular expressions, which you can view with vignette(\"regular-expressions\", \"stringr\"). If you want more practice, you can then follow along with the RegexOne tutorial or RegexTutorials. Any “perl-flavored” regex tutorial or resource will work, with the exception that you will have to double the number of backslashes (\\) to use them in R. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
